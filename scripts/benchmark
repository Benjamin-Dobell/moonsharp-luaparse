#!/usr/bin/env node
/*jshint node:true*/
/*globals console:true */
'use strict';

var Benchmark = require('benchmark')
  , memwatch = require('memwatch')
  , luaparse = require('../')
  , fs = require('fs')
  , path = require('path')
  , files = process.argv.slice(2)
  , suites = {}
  , suite = new Benchmark.Suite()
  , results = []
  , verbose = false
  , heap = false
  , minSamples = 5
  , minTime = 0;

if (!files.length) {
  console.log("Usage:\n\tbenchmark [snippet|file]...");
  console.log("Flags:\n\t-v|--verbose\n\t--samples=\n\t--minTime=\n\t--heap");
  process.exit(1);
}

files.forEach(function(file) {
  if (/^-v|--verbose/.test(file)) return verbose = true;
  if (/^--heap/.test(file)) return heap = true;
  if (/^--samples=/.test(file)) {
    minSamples = file.replace(/^--samples=/, '');
    return;
  }
  if (/^--minTime=/.test(file)) {
    minTime = file.replace(/^--minTime=/, '');
    return;
  }

  if (!fs.existsSync(file)) suites[path.basename(file)] = file;
  else suites[file] = fs.readFileSync(file, 'utf-8');
});

function insertHeap(file, source) {
  var hd, diff;
  for (var i = 0, l = minSamples; i < l; i++) {
    hd = new memwatch.HeapDiff();
    luaparse.parse(source);
    diff = hd.end();
    console.log(file + '\t' + diff.change.size);
  }
}

function insertBenchmark(file, source) {
  suite.add(file, function() {
    luaparse.parse(source);
  }, { minSamples: minSamples, minTime: minTime });
}

Object.keys(suites).forEach(function(file) {
  if (heap) insertHeap(file, suites[file]);
  else insertBenchmark(file, suites[file]);
});

if (!heap) {
  suite.on('cycle', function(event) {
    var stats = event.target.stats
      , mean = (stats.mean * 1000).toFixed(4)
      , variance = (stats.variance * 1000 * 1000).toFixed(4);
    if (verbose) console.log(String(event.target) + ' (' + mean + 'ms)');
    else console.log(mean + '\t' + variance);
  });
  suite.run();
}

/* vim: set sw=2 ts=2 et tw=80 ft=javascript : */
