<!DOCTYPE html>  <html> <head>   <title>luaparse.js</title>   <meta http-equiv="content-type" content="text/html; charset=UTF-8">   <link rel="stylesheet" media="all" href="docco.css" /> </head> <body>   <div id="container">     <div id="background"></div>          <table cellpadding="0" cellspacing="0">       <thead>         <tr>           <th class="docs">             <h1>               luaparse.js             </h1>           </th>           <th class="code">           </th>         </tr>       </thead>       <tbody>                               <tr id="section-1">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-1">&#182;</a>               </div>                            </td>             <td class="code">               <div class="highlight"><pre><span class="comment">/*global exports:true require:true define:true console:true */</span>

(<span class="function"><span class="keyword">function</span> <span class="params">(root, name, factory)</span> {</span>
  <span class="string">'use strict'</span>;

  <span class="keyword">if</span> (<span class="keyword">typeof</span> exports !== <span class="string">'undefined'</span>) {
    factory(exports);
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) {
    define([<span class="string">'exports'</span>], factory);
  } <span class="keyword">else</span> {
    factory((root[name] = {}));
  }
}(<span class="keyword">this</span>, <span class="string">'luaparse'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(exports)</span> {</span>
  <span class="string">'use strict'</span>;

  exports.version = <span class="string">'0.0.6'</span>;

  <span class="keyword">var</span> input, options, length;

  <span class="keyword">var</span> defaultOptions = exports.defaultOptions = {
</pre></div>             </td>           </tr>                               <tr id="section-2">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-2">&#182;</a>               </div>               <p>Explicitly tell the parser when the input ends.</p>             </td>             <td class="code">               <div class="highlight"><pre>      wait: <span class="literal">false</span>
</pre></div>             </td>           </tr>                               <tr id="section-3">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-3">&#182;</a>               </div>               <p>Store comments as an array in the chunk object.</p>             </td>             <td class="code">               <div class="highlight"><pre>    , comments: <span class="literal">true</span>
</pre></div>             </td>           </tr>                               <tr id="section-4">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-4">&#182;</a>               </div>               <p>Track identifier scopes by adding an isLocal attribute to each
identifier-node.</p>             </td>             <td class="code">               <div class="highlight"><pre>    , scope: <span class="literal">false</span>
  };

</pre></div>             </td>           </tr>                               <tr id="section-5">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-5">&#182;</a>               </div>               <p>The available tokens expressed as enum flags so they can be checked with
bitwise operations.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="keyword">var</span> EOF = <span class="number">1</span>, StringLiteral = <span class="number">2</span>, Keyword = <span class="number">4</span>, Identifier = <span class="number">8</span>
    , NumericLiteral = <span class="number">16</span>, Punctuator = <span class="number">32</span>, BooleanLiteral = <span class="number">64</span>
    , NilLiteral = <span class="number">128</span>, VarargLiteral = <span class="number">256</span>;

</pre></div>             </td>           </tr>                               <tr id="section-6">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-6">&#182;</a>               </div>               <p>As this parser is a bit different from luas own, the error messages
will be different in some situations.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="keyword">var</span> errors = exports.errors = {
      unexpected: <span class="string">'Unexpected %1 \'%2\' near \'%3\''</span>
    , expected: <span class="string">'\'%1\' expected near \'%2\''</span>
    , expectedToken: <span class="string">'%1 expected near \'%2\''</span>
    , unfinishedString: <span class="string">'unfinished string near \'%1\''</span>
    , malformedNumber: <span class="string">'malformed number near \'%1\''</span>
  };

</pre></div>             </td>           </tr>                               <tr id="section-7">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-7">&#182;</a>               </div>               <h3>Abstract Syntax Tree</h3>

<p>The default AST structure is inspired by the Mozilla Parser API but can
easily be customized by overriding these functions.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="keyword">var</span> ast = exports.ast = {
      labelStatement: <span class="keyword">function</span>(label) {
      <span class="keyword">return</span> {
          type: <span class="string">'LabelStatement'</span>
        , label: label
      };
    }

    , breakStatement: <span class="keyword">function</span>() {
      <span class="keyword">return</span> {
          type: <span class="string">'BreakStatement'</span>
      };
    }

    , gotoStatement: <span class="keyword">function</span>(label) {
      <span class="keyword">return</span> {
          type: <span class="string">'GotoStatement'</span>
        , label: label
      };
    }

    , returnStatement: <span class="keyword">function</span>(args) {
      <span class="keyword">return</span> {
          type: <span class="string">'ReturnStatement'</span>
        , <span class="string">'arguments'</span>: args
      };
    }

    , ifStatement: <span class="keyword">function</span>(clauses) {
      <span class="keyword">return</span> {
          type: <span class="string">'IfStatement'</span>
        , clauses: clauses
      };
    }
    , ifClause: <span class="keyword">function</span>(condition, body) {
      <span class="keyword">return</span> {
          type: <span class="string">'IfClause'</span>
        , condition: condition
        , body: body
      };
    }
    , elseifClause: <span class="keyword">function</span>(condition, body) {
      <span class="keyword">return</span> {
          type: <span class="string">'ElseifClause'</span>
        , condition: condition
        , body: body
      };
    }
    , elseClause: <span class="keyword">function</span>(body) {
      <span class="keyword">return</span> {
          type: <span class="string">'ElseClause'</span>
        , body: body
      };
    }

    , whileStatement: <span class="keyword">function</span>(condition, body) {
      <span class="keyword">return</span> {
          type: <span class="string">'WhileStatement'</span>
        , condition: condition
        , body: body
      };
    }

    , doStatement: <span class="keyword">function</span>(body) {
      <span class="keyword">return</span> {
          type: <span class="string">'DoStatement'</span>
        , body: body
      };
    }

    , repeatStatement: <span class="keyword">function</span>(condition, body) {
      <span class="keyword">return</span> {
          type: <span class="string">'RepeatStatement'</span>
        , condition: condition
        , body: body
      };
    }

    , localStatement: <span class="keyword">function</span>(variables, init) {
      <span class="keyword">return</span> {
          type: <span class="string">'LocalStatement'</span>
        , variables: variables
        , init: init
      };
    }

    , assignmentStatement: <span class="keyword">function</span>(variables, init) {
      <span class="keyword">return</span> {
          type: <span class="string">'AssignmentStatement'</span>
        , variables: variables
        , init: init
      };
    }

    , callStatement: <span class="keyword">function</span>(expression) {
      <span class="keyword">return</span> {
          type: <span class="string">'CallStatement'</span>
        , expression: expression
      };
    }

    , functionStatement: <span class="keyword">function</span>(identifier, parameters, isLocal, body) {
      <span class="keyword">return</span> {
          type: <span class="string">'FunctionDeclaration'</span>
        , identifier: identifier
        , local: isLocal
        , parameters: parameters
        , body: body
      };
    }

    , forNumericStatement: <span class="keyword">function</span>(variable, start, end, step, body) {
      <span class="keyword">return</span> {
          type: <span class="string">'ForNumericStatement'</span>
        , variable: variable
        , start: start
        , end: end
        , step: step
        , body: body
      };
    }

    , forGenericStatement: <span class="keyword">function</span>(variables, iterators, body) {
      <span class="keyword">return</span> {
          type: <span class="string">'ForGenericStatement'</span>
        , variables: variables
        , iterators: iterators
        , body: body
      };
    }

    , chunk: <span class="keyword">function</span>(body) {
      <span class="keyword">return</span> {
          type: <span class="string">'Chunk'</span>
        , body: body
      };
    }

    , identifier: <span class="keyword">function</span>(name) {
      <span class="keyword">return</span> {
          type: <span class="string">'Identifier'</span>
        , name: name
      };
    }

    , literal: <span class="keyword">function</span>(type, value, raw) {
      type = (type === StringLiteral) ? <span class="string">'StringLiteral'</span>
        : (type === NumericLiteral) ? <span class="string">'NumericLiteral'</span>
        : (type === BooleanLiteral) ? <span class="string">'BooleanLiteral'</span>
        : (type === NilLiteral) ? <span class="string">'NilLiteral'</span>
        : <span class="string">'VarargLiteral'</span>;

      <span class="keyword">return</span> {
          type: type
        , value: value
        , raw: raw
      };
    }

    , tableKey: <span class="keyword">function</span>(key, value) {
      <span class="keyword">return</span> {
          type: <span class="string">'TableKey'</span>
        , key: key
        , value: value
      };
    }
    , tableKeyString: <span class="keyword">function</span>(key, value) {
      <span class="keyword">return</span> {
          type: <span class="string">'TableKeyString'</span>
        , key: key
        , value: value
      };
    }
    , tableValue: <span class="keyword">function</span>(value) {
      <span class="keyword">return</span> {
          type: <span class="string">'TableValue'</span>
        , value: value
      };
    }


    , tableConstructorExpression: <span class="keyword">function</span>(fields) {
      <span class="keyword">return</span> {
          type: <span class="string">'TableConstructorExpression'</span>
        , fields: fields
      };
    }
    , binaryExpression: <span class="keyword">function</span>(operator, left, right) {
      <span class="keyword">var</span> type = (<span class="string">'and'</span> === operator || <span class="string">'or'</span> === operator) ?
        <span class="string">'LogicalExpression'</span> :
        <span class="string">'BinaryExpression'</span>;

      <span class="keyword">return</span> {
          type: type
        , operator: operator
        , left: left
        , right: right
      };
    }
    , unaryExpression: <span class="keyword">function</span>(operator, argument) {
      <span class="keyword">return</span> {
          type: <span class="string">'UnaryExpression'</span>
        , operator: operator
        , argument: argument
      };
    }
    , memberExpression: <span class="keyword">function</span>(base, indexer, identifier) {
      <span class="keyword">return</span> {
          type: <span class="string">'MemberExpression'</span>
        , indexer: indexer
        , identifier: identifier
        , base: base
      };
    }

    , indexExpression: <span class="keyword">function</span>(base, index) {
      <span class="keyword">return</span> {
          type: <span class="string">'IndexExpression'</span>
        , base: base
        , index: index
      };
    }

    , callExpression: <span class="keyword">function</span>(base, args) {
      <span class="keyword">return</span> {
          type: <span class="string">'CallExpression'</span>
        , base: base
        , <span class="string">'arguments'</span>: args
      };
    }

    , tableCallExpression: <span class="keyword">function</span>(base, args) {
      <span class="keyword">return</span> {
          type: <span class="string">'TableCallExpression'</span>
        , base: base
        , <span class="string">'arguments'</span>: args
      };
    }

    , stringCallExpression: <span class="keyword">function</span>(base, argument) {
      <span class="keyword">return</span> {
          type: <span class="string">'StringCallExpression'</span>
        , base: base
        , argument: argument
      };
    }
  };

</pre></div>             </td>           </tr>                               <tr id="section-8">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-8">&#182;</a>               </div>               <h2>Helpers</h2>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="keyword">var</span> slice = Array.prototype.slice
    , toString = Object.prototype.toString
</pre></div>             </td>           </tr>                               <tr id="section-9">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-9">&#182;</a>               </div>               <p>Simple indexOf implementation which only provides what's required.</p>             </td>             <td class="code">               <div class="highlight"><pre>    , indexOf = Array.prototype.indexOf || <span class="function"><span class="keyword">function</span> <span class="title">indexOf</span><span class="params">(element)</span> {</span>
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = <span class="keyword">this</span>.length; i &lt; length; i++) {
        <span class="keyword">if</span> (<span class="keyword">this</span>[i] === element) <span class="keyword">return</span> i;
      }
      <span class="keyword">return</span> -<span class="number">1</span>;
    };

</pre></div>             </td>           </tr>                               <tr id="section-10">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-10">&#182;</a>               </div>               <p>A sprintf implementation using %index (beginning at 1) to input
arguments in the format string.</p>

<p>Example:</p>

<pre><code>// Unexpected function in token
sprintf('Unexpected %2 in %1.', 'token', 'function');
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">sprintf</span><span class="params">(format)</span> {</span>
    <span class="keyword">var</span> args = slice.call(arguments, <span class="number">1</span>);
    format = format.replace(<span class="regexp">/%(\d)/g</span>, <span class="function"><span class="keyword">function</span> <span class="params">(match, index)</span> {</span>
      match = <span class="string">''</span>; <span class="comment">// jshint</span>
      <span class="keyword">return</span> <span class="string">''</span> + args[index - <span class="number">1</span>] || <span class="string">''</span>;
    });
    <span class="keyword">return</span> format;
  }

</pre></div>             </td>           </tr>                               <tr id="section-11">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-11">&#182;</a>               </div>               <p>Returns a new object with the properties from all objectes passed as
arguments. Last argument takes precedence.</p>

<p>Example:</p>

<pre><code>this.options = extend(options, { output: false });
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> args = slice.call(arguments)
      , dest = {}
      , src, prop;

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = args.length; i &lt; l; i++) {
      src = args[i];
      <span class="keyword">for</span> (prop <span class="keyword">in</span> src) <span class="keyword">if</span> (src.hasOwnProperty(prop)) {
        dest[prop] = src[prop];
      }
    }
    <span class="keyword">return</span> dest;
  }

</pre></div>             </td>           </tr>                               <tr id="section-12">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-12">&#182;</a>               </div>               <h3>Error functions</h3>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-13">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-13">&#182;</a>               </div>               <h4>Raise an exception.</h4>

<p>Raise an exception by passing a token, a string format and its paramters.</p>

<p>The passed tokens location will automatically be added to the error
message if it exists, if not it will default to the lexers current
position.</p>

<p>Example:</p>

<pre><code>// [1:0] expected [ near (
raise(token, "expected %1 near %2", '[', token.value);
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">raise</span><span class="params">(token)</span> {</span>
    <span class="keyword">var</span> message = sprintf.apply(<span class="literal">null</span>, slice.call(arguments, <span class="number">1</span>))
      , error, col;

    <span class="keyword">if</span> (<span class="string">'undefined'</span> !== <span class="keyword">typeof</span> token.line) {
      col = token.range[<span class="number">0</span>] - token.lineStart;
      error = <span class="keyword">new</span> SyntaxError(sprintf(<span class="string">'[%1:%2] %3'</span>, token.line, col, message));
      error.line = token.line;
      error.index = token.range[<span class="number">0</span>];
      error.column = col;
    } <span class="keyword">else</span> {
      col = index - lineStart + <span class="number">1</span>;
      error = <span class="keyword">new</span> SyntaxError(sprintf(<span class="string">'[%1:%2] %3'</span>, line, col, message));
      error.index = index;
      error.line = line;
      error.column = col;
    }
    <span class="keyword">throw</span> error;
  }

</pre></div>             </td>           </tr>                               <tr id="section-14">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-14">&#182;</a>               </div>               <h4>Raise an unexpected token error.</h4>

<p>Example:</p>

<pre><code>// expected &lt;name&gt; near '0'
raiseUnexpectedToken('&lt;name&gt;', token);
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">raiseUnexpectedToken</span><span class="params">(type, token)</span> {</span>
    raise(token, errors.expectedToken, type, token.value);
  }

</pre></div>             </td>           </tr>                               <tr id="section-15">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-15">&#182;</a>               </div>               <h4>Raise a general unexpected error</h4>

<p>Usage should pass either a token object or a symbol string which was
expected. We can also specify a nearby token such as <eof>, this will
default to the currently active token.</p>

<p>Example:</p>

<pre><code>// Unexpected symbol 'end' near '&lt;eof&gt;'
unexpected(token);
</code></pre>

<p>If there's no token in the buffer it means we have reached <eof>.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">unexpected</span><span class="params">(found, near)</span> {</span>
    <span class="keyword">if</span> (<span class="string">'undefined'</span> === <span class="keyword">typeof</span> near) near = lookahead.value;
    <span class="keyword">if</span> (<span class="string">'undefined'</span> !== <span class="keyword">typeof</span> found.type) {
      <span class="keyword">var</span> type;
      <span class="keyword">switch</span> (found.type) {
        <span class="keyword">case</span> StringLiteral:   type = <span class="string">'string'</span>;      <span class="keyword">break</span>;
        <span class="keyword">case</span> Keyword:         type = <span class="string">'keyword'</span>;     <span class="keyword">break</span>;
        <span class="keyword">case</span> Identifier:      type = <span class="string">'identifier'</span>;  <span class="keyword">break</span>;
        <span class="keyword">case</span> NumericLiteral:  type = <span class="string">'number'</span>;      <span class="keyword">break</span>;
        <span class="keyword">case</span> Punctuator:      type = <span class="string">'symbol'</span>;      <span class="keyword">break</span>;
        <span class="keyword">case</span> BooleanLiteral:  type = <span class="string">'boolean'</span>;     <span class="keyword">break</span>;
        <span class="keyword">case</span> NilLiteral:
          <span class="keyword">return</span> raise(found, errors.unexpected, <span class="string">'symbol'</span>, <span class="string">'nil'</span>, near);
      }
      <span class="keyword">return</span> raise(found, errors.unexpected, type, found.value, near);
    }
    <span class="keyword">return</span> raise(found, errors.unexpected, <span class="string">'symbol'</span>, found, near);
  }

</pre></div>             </td>           </tr>                               <tr id="section-16">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-16">&#182;</a>               </div>               <h2>Lexer</h2>

<p>The lexer, or the tokenizer reads the input string character by character
and derives a token left-right. To be as efficient as possible the lexer
prioritizes the common cases such as identifiers. It also works with
character codes instead of characters as string comparisons was the
biggest bottleneck of the parser.</p>

<p>If <code>options.comments</code> is enabled, all comments encountered will be stored
in an array which later will be appended to the chunk object. If disabled,
they will simply be disregarded.</p>

<p>When the lexer has derived a valid token, it will be returned as an object
containing its value and as well as its position in the input string (this
is always enabled to provide proper debug messages).</p>

<p><code>readToken()</code> starts lexing and returns the following token in the stream.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="keyword">var</span> index
    , token
    , lookahead
    , comments
    , tokenStart
    , line
    , lineStart;

  <span class="function"><span class="keyword">function</span> <span class="title">readToken</span><span class="params">()</span> {</span>
    skipWhiteSpace();

</pre></div>             </td>           </tr>                               <tr id="section-17">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-17">&#182;</a>               </div>               <p>Skip comments beginning with --</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">while</span> (<span class="number">45</span> === input.charCodeAt(index) &amp;&amp;
           <span class="number">45</span> === input.charCodeAt(index + <span class="number">1</span>)) {
      scanComment();
      skipWhiteSpace();
    }
    <span class="keyword">if</span> (index &gt;= length) <span class="keyword">return</span> {
        type : EOF
      , value: <span class="string">'&lt;eof&gt;'</span>
      , line: line
      , lineStart: lineStart
      , range: [index, index]
    };

    <span class="keyword">var</span> char = input.charCodeAt(index)
      , next = input.charCodeAt(index + <span class="number">1</span>);

</pre></div>             </td>           </tr>                               <tr id="section-18">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-18">&#182;</a>               </div>               <p>Memorize the range index where the token begins.</p>             </td>             <td class="code">               <div class="highlight"><pre>    tokenStart = index;
    <span class="keyword">if</span> (isIdentifierStart(char)) <span class="keyword">return</span> scanIdentifierOrKeyword();

    <span class="keyword">switch</span> (char) {
      <span class="keyword">case</span> <span class="number">39</span>: <span class="keyword">case</span> <span class="number">34</span>: <span class="comment">// '"</span>
        <span class="keyword">return</span> scanStringLiteral();

</pre></div>             </td>           </tr>                               <tr id="section-19">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-19">&#182;</a>               </div>               <p>0-9</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">case</span> <span class="number">48</span>: <span class="keyword">case</span> <span class="number">49</span>: <span class="keyword">case</span> <span class="number">50</span>: <span class="keyword">case</span> <span class="number">51</span>: <span class="keyword">case</span> <span class="number">52</span>: <span class="keyword">case</span> <span class="number">53</span>:
      <span class="keyword">case</span> <span class="number">54</span>: <span class="keyword">case</span> <span class="number">55</span>: <span class="keyword">case</span> <span class="number">56</span>: <span class="keyword">case</span> <span class="number">57</span>:
        <span class="keyword">return</span> scanNumericLiteral();

      <span class="keyword">case</span> <span class="number">46</span>: <span class="comment">// .</span>
</pre></div>             </td>           </tr>                               <tr id="section-20">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-20">&#182;</a>               </div>               <p>If the dot is followed by a digit it's a float.</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="keyword">if</span> (isDecDigit(next)) <span class="keyword">return</span> scanNumericLiteral();
        <span class="keyword">if</span> (<span class="number">46</span> === next) {
          <span class="keyword">if</span> (<span class="number">46</span> === input.charCodeAt(index + <span class="number">2</span>)) <span class="keyword">return</span> scanVarargLiteral();
          <span class="keyword">return</span> scanPunctuator(<span class="string">'..'</span>);
        }
        <span class="keyword">return</span> scanPunctuator(<span class="string">'.'</span>);

      <span class="keyword">case</span> <span class="number">61</span>: <span class="comment">// =</span>
        <span class="keyword">if</span> (<span class="number">61</span> === next) <span class="keyword">return</span> scanPunctuator(<span class="string">'=='</span>);
        <span class="keyword">return</span> scanPunctuator(<span class="string">'='</span>);

      <span class="keyword">case</span> <span class="number">62</span>: <span class="comment">// &gt;</span>
        <span class="keyword">if</span> (<span class="number">61</span> === next) <span class="keyword">return</span> scanPunctuator(<span class="string">'&gt;='</span>);
        <span class="keyword">return</span> scanPunctuator(<span class="string">'&gt;'</span>);

      <span class="keyword">case</span> <span class="number">60</span>: <span class="comment">// &lt;</span>
        <span class="keyword">if</span> (<span class="number">61</span> === next) <span class="keyword">return</span> scanPunctuator(<span class="string">'&lt;='</span>);
        <span class="keyword">return</span> scanPunctuator(<span class="string">'&lt;'</span>);

      <span class="keyword">case</span> <span class="number">126</span>: <span class="comment">// ~</span>
        <span class="keyword">if</span> (<span class="number">61</span> === next) <span class="keyword">return</span> scanPunctuator(<span class="string">'~='</span>);
        <span class="keyword">return</span> raise({}, errors.expected, <span class="string">'='</span>, <span class="string">'~'</span>);

      <span class="keyword">case</span> <span class="number">58</span>: <span class="comment">// :</span>
        <span class="keyword">if</span> (<span class="number">58</span> === next) <span class="keyword">return</span> scanPunctuator(<span class="string">'::'</span>);
        <span class="keyword">return</span> scanPunctuator(<span class="string">':'</span>);

      <span class="keyword">case</span> <span class="number">91</span>: <span class="comment">// [</span>
</pre></div>             </td>           </tr>                               <tr id="section-21">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-21">&#182;</a>               </div>               <p>Check for a multiline string, they begin with [= or [[</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="keyword">if</span> (<span class="number">91</span> === next || <span class="number">61</span> === next) <span class="keyword">return</span> scanLongStringLiteral();
        <span class="keyword">return</span> scanPunctuator(<span class="string">'['</span>);

</pre></div>             </td>           </tr>                               <tr id="section-22">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-22">&#182;</a>               </div>               <p>* / ^ % , { } ] ( ) ; # - +</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">case</span> <span class="number">42</span>: <span class="keyword">case</span> <span class="number">47</span>: <span class="keyword">case</span> <span class="number">94</span>: <span class="keyword">case</span> <span class="number">37</span>: <span class="keyword">case</span> <span class="number">44</span>: <span class="keyword">case</span> <span class="number">123</span>: <span class="keyword">case</span> <span class="number">125</span>:
      <span class="keyword">case</span> <span class="number">93</span>: <span class="keyword">case</span> <span class="number">40</span>: <span class="keyword">case</span> <span class="number">41</span>: <span class="keyword">case</span> <span class="number">59</span>: <span class="keyword">case</span> <span class="number">35</span>: <span class="keyword">case</span> <span class="number">45</span>: <span class="keyword">case</span> <span class="number">43</span>:
        <span class="keyword">return</span> scanPunctuator(input.charAt(index));
    }

    <span class="keyword">return</span> unexpected(input.charAt(index));
  }

</pre></div>             </td>           </tr>                               <tr id="section-23">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-23">&#182;</a>               </div>               <p>Whitespace has no semantic meaning in lua so simply skip ahead while
tracking the encounted newlines. Newlines are also tracked in all
token functions where multiline values are allowed.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">skipWhiteSpace</span><span class="params">()</span> {</span>
    <span class="keyword">while</span> (index &lt; length) {
      <span class="keyword">var</span> char = input.charCodeAt(index);
      <span class="keyword">if</span> (isWhiteSpace(char)) {
        index++;
      } <span class="keyword">else</span> <span class="keyword">if</span> (isLineTerminator(char)) {
        line++;
        lineStart = ++index;
      } <span class="keyword">else</span> {
        <span class="keyword">break</span>;
      }
    }
  }

</pre></div>             </td>           </tr>                               <tr id="section-24">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-24">&#182;</a>               </div>               <p>Identifiers, keywords, booleans and nil all look the same syntax wise. We
simply go through them one by one and defaulting to an identifier if no
previous case matched.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanIdentifierOrKeyword</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> value, type;

</pre></div>             </td>           </tr>                               <tr id="section-25">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-25">&#182;</a>               </div>               <p>Slicing the input string is prefered before string concatenation in a
loop for performance reasons.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">while</span> (isIdentifierPart(input.charCodeAt(++index)));
    value = input.slice(tokenStart, index);

</pre></div>             </td>           </tr>                               <tr id="section-26">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-26">&#182;</a>               </div>               <p>Decide on the token type and possibly cast the value.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (isKeyword(value)) {
      type = Keyword;
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'true'</span> === value || <span class="string">'false'</span> === value) {
      type = BooleanLiteral;
      value = (<span class="string">'true'</span> === value);
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'nil'</span> === value) {
      type = NilLiteral;
      value = <span class="literal">null</span>;
    } <span class="keyword">else</span> {
      type = Identifier;
    }

    <span class="keyword">return</span> {
        type: type
      , value: value
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

</pre></div>             </td>           </tr>                               <tr id="section-27">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-27">&#182;</a>               </div>               <p>Once a punctuator reaches this function it should already have been
validated so we simply return it as a token.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanPunctuator</span><span class="params">(value)</span> {</span>
    index += value.length;
    <span class="keyword">return</span> {
        type: Punctuator
      , value: value
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

</pre></div>             </td>           </tr>                               <tr id="section-28">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-28">&#182;</a>               </div>               <p>A vararg literal consists of three dots.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanVarargLiteral</span><span class="params">()</span> {</span>
    index += <span class="number">3</span>;
    <span class="keyword">return</span> {
        type: VarargLiteral
      , value: <span class="string">'...'</span>
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

</pre></div>             </td>           </tr>                               <tr id="section-29">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-29">&#182;</a>               </div>               <p>Find the string literal by matching the delimiter marks used.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanStringLiteral</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> delimiter = input.charCodeAt(index++)
      , stringStart = index
      , string = <span class="string">''</span>
      , char;

    <span class="keyword">while</span> (index &lt; length) {
      char = input.charCodeAt(index++);
      <span class="keyword">if</span> (delimiter === char) <span class="keyword">break</span>;
      <span class="keyword">if</span> (<span class="number">92</span> === char) { <span class="comment">// \</span>
        string += input.slice(stringStart, index - <span class="number">1</span>) + readEscapeSequence();
        stringStart = index;
      }
</pre></div>             </td>           </tr>                               <tr id="section-30">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-30">&#182;</a>               </div>               <p>EOF or <code>\n</code> terminates a string literal. If we haven't found the
ending delimiter by now, raise an exception.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= length || isLineTerminator(char)) {
        string += input.slice(stringStart, index - <span class="number">1</span>);
        raise({}, errors.unfinishedString, string + String.fromCharCode(char));
      }
    }
    string += input.slice(stringStart, index - <span class="number">1</span>);

    <span class="keyword">return</span> {
        type: StringLiteral
      , value: string
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

</pre></div>             </td>           </tr>                               <tr id="section-31">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-31">&#182;</a>               </div>               <p>Expect a multiline string literal and return it as a regular string
literal, if it doesn't validate into a valid multiline string, throw an
exception.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanLongStringLiteral</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> string = readLongString();
</pre></div>             </td>           </tr>                               <tr id="section-32">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-32">&#182;</a>               </div>               <p>Fail if it's not a multiline literal.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (<span class="literal">false</span> === string) raise(token, errors.expected, <span class="string">'['</span>, token.value);

    <span class="keyword">return</span> {
        type: StringLiteral
      , value: string
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

</pre></div>             </td>           </tr>                               <tr id="section-33">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-33">&#182;</a>               </div>               <p>Numeric literals will be returned as floating-point numbers instead of
strings. The raw value should be retrieved from slicing the input string
later on in the process.</p>

<p>If a hexadecimal number is encountered, it will be converted.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanNumericLiteral</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> char = input.charAt(index)
      , next = input.charAt(index + <span class="number">1</span>);

    <span class="keyword">var</span> value = (<span class="string">'0'</span> === char &amp;&amp; ~<span class="string">'xX'</span>.indexOf(next || <span class="literal">null</span>)) ?
      readHexLiteral() : readDecLiteral();

    <span class="keyword">return</span> {
        type: NumericLiteral
      , value: value
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

</pre></div>             </td>           </tr>                               <tr id="section-34">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-34">&#182;</a>               </div>               <p>Lua hexadecimals have an optional fraction part and an optional binary
exoponent part. These are not included in JavaScript so we will compute
all three parts separately and then sum them up at the end of the function
with the following algorithm.</p>

<pre><code>Digit := toDec(digit)
Fraction := toDec(fraction) / 16 ^ fractionCount
BinaryExp := 2 ^ binaryExp
Number := ( Digit + Fraction ) * BinaryExp
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">readHexLiteral</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> fraction = <span class="number">0</span> <span class="comment">// defaults to 0 as it gets summed</span>
      , binaryExponent = <span class="number">1</span> <span class="comment">// defaults to 1 as it gets multiplied</span>
      , binarySign = <span class="number">1</span> <span class="comment">// positive</span>
      , digit, fractionStart, exponentStart, digitStart;

    digitStart = index += <span class="number">2</span>; <span class="comment">// Skip 0x part</span>

</pre></div>             </td>           </tr>                               <tr id="section-35">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-35">&#182;</a>               </div>               <p>A minimum of one hex digit is required.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (!isHexDigit(input.charCodeAt(index)))
      raise({}, errors.malformedNumber, input.slice(tokenStart, index));

    <span class="keyword">while</span> (isHexDigit(input.charCodeAt(index))) index++;
</pre></div>             </td>           </tr>                               <tr id="section-36">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-36">&#182;</a>               </div>               <p>Convert the hexadecimal digit to base 10.</p>             </td>             <td class="code">               <div class="highlight"><pre>    digit = parseInt(input.slice(digitStart, index), <span class="number">16</span>);

</pre></div>             </td>           </tr>                               <tr id="section-37">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-37">&#182;</a>               </div>               <p>Fraction part i optional.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (<span class="string">'.'</span> === input.charAt(index)) {
      fractionStart = ++index;

      <span class="keyword">while</span> (isHexDigit(input.charCodeAt(index))) index++;
      fraction = input.slice(fractionStart, index);

</pre></div>             </td>           </tr>                               <tr id="section-38">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-38">&#182;</a>               </div>               <p>Empty fraction parts should default to 0, others should be converted
0.x form so we can use summation at the end.</p>             </td>             <td class="code">               <div class="highlight"><pre>      fraction = (fractionStart === index) ? <span class="number">0</span>
        : parseInt(fraction, <span class="number">16</span>) / Math.pow(<span class="number">16</span>, index - fractionStart);
    }

</pre></div>             </td>           </tr>                               <tr id="section-39">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-39">&#182;</a>               </div>               <p>Binary exponents are optional</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (~<span class="string">'pP'</span>.indexOf(input.charAt(index) || <span class="literal">null</span>)) {
      index++;

</pre></div>             </td>           </tr>                               <tr id="section-40">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-40">&#182;</a>               </div>               <p>Sign part is optional and defaults to 1 (positive).</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (~<span class="string">'+-'</span>.indexOf(input.charAt(index) || <span class="literal">null</span>))
        binarySign = (<span class="string">'+'</span> === input.charAt(index++)) ? <span class="number">1</span> : -<span class="number">1</span>;

      exponentStart = index;

</pre></div>             </td>           </tr>                               <tr id="section-41">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-41">&#182;</a>               </div>               <p>The binary exponent sign requires a decimal digit.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (!isDecDigit(input.charCodeAt(index)))
        raise({}, errors.malformedNumber, input.slice(tokenStart, index));

      <span class="keyword">while</span> (isDecDigit(input.charCodeAt(index))) index++;
      binaryExponent = input.slice(exponentStart, index);

</pre></div>             </td>           </tr>                               <tr id="section-42">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-42">&#182;</a>               </div>               <p>Calculate the binary exponent of the number.</p>             </td>             <td class="code">               <div class="highlight"><pre>      binaryExponent = Math.pow(<span class="number">2</span>, binaryExponent * binarySign);
    }

    <span class="keyword">return</span> (digit + fraction) * binaryExponent;
  }

</pre></div>             </td>           </tr>                               <tr id="section-43">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-43">&#182;</a>               </div>               <p>Decimal numbers are exactly the same in Lua and in JavaScript, because of
this we check where the token ends and then parse it with native
functions.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">readDecLiteral</span><span class="params">()</span> {</span>
    <span class="keyword">while</span> (isDecDigit(input.charCodeAt(index))) index++;
</pre></div>             </td>           </tr>                               <tr id="section-44">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-44">&#182;</a>               </div>               <p>Fraction part is optional</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (<span class="string">'.'</span> === input.charAt(index)) {
      index++;
</pre></div>             </td>           </tr>                               <tr id="section-45">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-45">&#182;</a>               </div>               <p>Fraction part defaults to 0</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">while</span> (isDecDigit(input.charCodeAt(index))) index++;
    }
</pre></div>             </td>           </tr>                               <tr id="section-46">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-46">&#182;</a>               </div>               <p>Exponent part is optional.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (~<span class="string">'eE'</span>.indexOf(input.charAt(index) || <span class="literal">null</span>)) {
      index++;
</pre></div>             </td>           </tr>                               <tr id="section-47">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-47">&#182;</a>               </div>               <p>Sign part is optional.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (~<span class="string">'+-'</span>.indexOf(input.charAt(index) || <span class="literal">null</span>)) index++;
</pre></div>             </td>           </tr>                               <tr id="section-48">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-48">&#182;</a>               </div>               <p>An exponent is required to contain at least one decimal digit.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (!isDecDigit(input.charCodeAt(index)))
        raise({}, errors.malformedNumber, input.slice(tokenStart, index));

      <span class="keyword">while</span> (isDecDigit(input.charCodeAt(index))) index++;
    }

    <span class="keyword">return</span> parseFloat(input.slice(tokenStart, index));
  }


</pre></div>             </td>           </tr>                               <tr id="section-49">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-49">&#182;</a>               </div>               <p>Translate escape sequences to the actual characters.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">readEscapeSequence</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> sequenceStart = index;
    <span class="keyword">switch</span> (input.charAt(index)) {
</pre></div>             </td>           </tr>                               <tr id="section-50">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-50">&#182;</a>               </div>               <p>Lua allow the following escape sequences.
We don't escape the bell sequence.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">case</span> <span class="string">'n'</span>: index++; <span class="keyword">return</span> <span class="string">'\n'</span>;
      <span class="keyword">case</span> <span class="string">'r'</span>: index++; <span class="keyword">return</span> <span class="string">'\r'</span>;
      <span class="keyword">case</span> <span class="string">'t'</span>: index++; <span class="keyword">return</span> <span class="string">'\t'</span>;
      <span class="keyword">case</span> <span class="string">'v'</span>: index++; <span class="keyword">return</span> <span class="string">'\v'</span>;
      <span class="keyword">case</span> <span class="string">'b'</span>: index++; <span class="keyword">return</span> <span class="string">'\b'</span>;
      <span class="keyword">case</span> <span class="string">'f'</span>: index++; <span class="keyword">return</span> <span class="string">'\f'</span>;
</pre></div>             </td>           </tr>                               <tr id="section-51">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-51">&#182;</a>               </div>               <p>Skips the following span of white-space.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">case</span> <span class="string">'z'</span>: index++; skipWhiteSpace(); <span class="keyword">return</span> <span class="string">''</span>;
</pre></div>             </td>           </tr>                               <tr id="section-52">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-52">&#182;</a>               </div>               <p>Byte representation should for now be returned as is.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">case</span> <span class="string">'x'</span>:
</pre></div>             </td>           </tr>                               <tr id="section-53">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-53">&#182;</a>               </div>               <p>\xXX, where XX is a sequence of exactly two hexadecimal digits</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="keyword">if</span> (isHexDigit(input.charCodeAt(index + <span class="number">1</span>)) &amp;&amp;
            isHexDigit(input.charCodeAt(index + <span class="number">2</span>))) {
          index += <span class="number">3</span>;
</pre></div>             </td>           </tr>                               <tr id="section-54">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-54">&#182;</a>               </div>               <p>Return it as is, without translating the byte.</p>             </td>             <td class="code">               <div class="highlight"><pre>          <span class="keyword">return</span> <span class="string">'\\'</span> + input.slice(sequenceStart, index);
        }
        <span class="keyword">return</span> <span class="string">'\\'</span> + input.charAt(index++);
      <span class="keyword">default</span>:
</pre></div>             </td>           </tr>                               <tr id="section-55">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-55">&#182;</a>               </div>               <p>\ddd, where ddd is a sequence of up to three decimal digits.</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="keyword">if</span> (isDecDigit(input.charCodeAt(index))) {
          <span class="keyword">while</span> (isDecDigit(input.charCodeAt(++index)));
          <span class="keyword">return</span> <span class="string">'\\'</span> + input.slice(sequenceStart, index);
        }
</pre></div>             </td>           </tr>                               <tr id="section-56">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-56">&#182;</a>               </div>               <p>Simply return the \ as is, it's not escaping any sequence.</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="keyword">return</span> input.charAt(index++);
    }
  }

</pre></div>             </td>           </tr>                               <tr id="section-57">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-57">&#182;</a>               </div>               <p>Comments begin with -- after which it will be decided if they are
multiline comments or not.</p>

<p>The multiline functionality works the exact same way as with string
literals so we reuse the functionality.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanComment</span><span class="params">()</span> {</span>
    tokenStart = index;
    index += <span class="number">2</span>; <span class="comment">// --</span>

    <span class="keyword">var</span> char = input.charAt(index)
      , content = <span class="string">''</span>
      , isLong = <span class="literal">false</span>
      , commentStart = index;

    <span class="keyword">if</span> (<span class="string">'['</span> === char) {
      content = readLongString();
</pre></div>             </td>           </tr>                               <tr id="section-58">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-58">&#182;</a>               </div>               <p>This wasn't a multiline comment after all.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (<span class="literal">false</span> === content) content = char;
      <span class="keyword">else</span> {
        isLong = <span class="literal">true</span>;
        index += <span class="number">2</span>; <span class="comment">// Trailing --</span>
      }
    }
</pre></div>             </td>           </tr>                               <tr id="section-59">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-59">&#182;</a>               </div>               <p>Scan until next line as long as it's not a multiline comment.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (!isLong) {
      <span class="keyword">while</span> (index &lt; length) {
        <span class="keyword">if</span> (isLineTerminator(input.charCodeAt(index))) <span class="keyword">break</span>;
        index++;
      }
      content = input.slice(commentStart, index);
    }

    <span class="keyword">if</span> (options.comments) {
      comments.push({
          type: <span class="string">'Comment'</span>
        , value: content
        , raw: input.slice(tokenStart, index)
      });
    }
  }

</pre></div>             </td>           </tr>                               <tr id="section-60">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-60">&#182;</a>               </div>               <p>Read a multiline string by calculating the depth of <code>=</code> characters and
then appending until an equal depth is found.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">readLongString</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> level = <span class="number">0</span>
      , content = <span class="string">''</span>
      , terminator = <span class="literal">false</span>
      , char, stringStart;

    index++; <span class="comment">// [</span>

</pre></div>             </td>           </tr>                               <tr id="section-61">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-61">&#182;</a>               </div>               <p>Calculate the depth of the comment.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">while</span> (<span class="string">'='</span> === input.charAt(index + level)) level++;
</pre></div>             </td>           </tr>                               <tr id="section-62">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-62">&#182;</a>               </div>               <p>Exit, this is not a long string afterall.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (<span class="string">'['</span> !== input.charAt(index + level)) <span class="keyword">return</span> <span class="literal">false</span>;

    index += level + <span class="number">1</span>;

</pre></div>             </td>           </tr>                               <tr id="section-63">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-63">&#182;</a>               </div>               <p>If the first character is a newline, ignore it and begin on next line.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (isLineTerminator(input.charCodeAt(index))) {
      line++;
      lineStart = index++;
    }

    stringStart = index;
    <span class="keyword">while</span> (index &lt; length) {
      char = input.charAt(index++);

</pre></div>             </td>           </tr>                               <tr id="section-64">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-64">&#182;</a>               </div>               <p>We have to keep track of newlines as <code>skipWhiteSpace()</code> does not get
to scan this part.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (isLineTerminator(char.charCodeAt(<span class="number">0</span>))) {
        line++;
        lineStart = index;
      }

</pre></div>             </td>           </tr>                               <tr id="section-65">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-65">&#182;</a>               </div>               <p>Once the delimiter is found, iterate through the depth count and see
if it matches.</p>             </td>             <td class="code">               <div class="highlight"><pre>
      <span class="keyword">if</span> (<span class="string">']'</span> === char) {
        terminator = <span class="literal">true</span>;
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; level; i++) {
          <span class="keyword">if</span> (<span class="string">'='</span> !== input.charAt(index + i)) terminator = <span class="literal">false</span>;
        }
        <span class="keyword">if</span> (<span class="string">']'</span> !== input.charAt(index + level)) terminator = <span class="literal">false</span>;
      }

</pre></div>             </td>           </tr>                               <tr id="section-66">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-66">&#182;</a>               </div>               <p>We reached the end of the multiline string. Get out now.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (terminator) <span class="keyword">break</span>;

      <span class="keyword">if</span> (<span class="string">'\\'</span> === char) {
        content += input.slice(stringStart, index - <span class="number">1</span>) + readEscapeSequence();
        stringStart = index;
      }
    }
    content += input.slice(stringStart, index - <span class="number">1</span>);
    index += level + <span class="number">1</span>;

    <span class="keyword">return</span> content;
  }

</pre></div>             </td>           </tr>                               <tr id="section-67">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-67">&#182;</a>               </div>               <h2>Lex functions and helpers.</h2>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-68">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-68">&#182;</a>               </div>               <p>Read the next token.</p>

<p>This is actually done by setting the current token to the lookahead and
reading in the new lookahead token.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span> {</span>
    token = lookahead;
    lookahead = readToken();
  }

</pre></div>             </td>           </tr>                               <tr id="section-69">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-69">&#182;</a>               </div>               <p>Consume a token if its value matches. Once consumed or not, return the
success of the operation.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">consume</span><span class="params">(value)</span> {</span>
    <span class="keyword">if</span> (value === token.value) {
      next();
      <span class="keyword">return</span> <span class="literal">true</span>;
    }
    <span class="keyword">return</span> <span class="literal">false</span>;
  }

</pre></div>             </td>           </tr>                               <tr id="section-70">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-70">&#182;</a>               </div>               <p>Check if the given expression exists and raise an exception if not.</p>

<p>As expressions can return null due to the design of the parser, we often
need this strict expression check as well.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">expectExpression</span><span class="params">(expression)</span> {</span>
    <span class="keyword">if</span> (<span class="literal">null</span> == expression) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token);
    <span class="keyword">else</span> <span class="keyword">return</span> expression;
  }

</pre></div>             </td>           </tr>                               <tr id="section-71">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-71">&#182;</a>               </div>               <p>Expect the next token value to match. If not, throw an exception.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">expect</span><span class="params">(value)</span> {</span>
    <span class="keyword">if</span> (value === token.value) next();
    <span class="keyword">else</span> raise(token, errors.expected, value, token.value);
  }

</pre></div>             </td>           </tr>                               <tr id="section-72">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-72">&#182;</a>               </div>               <h3>Validation functions</h3>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">isWhiteSpace</span><span class="params">(char)</span> {</span>
    <span class="keyword">return</span> <span class="number">9</span> === char || <span class="number">32</span> === char || <span class="number">0xB</span> === char || <span class="number">0xC</span> === char;
  }

  <span class="function"><span class="keyword">function</span> <span class="title">isLineTerminator</span><span class="params">(char)</span> {</span>
    <span class="keyword">return</span> <span class="number">10</span> === char || <span class="number">13</span> === char;
  }

  <span class="function"><span class="keyword">function</span> <span class="title">isDecDigit</span><span class="params">(char)</span> {</span>
    <span class="keyword">return</span> char &gt;= <span class="number">48</span> &amp;&amp; char &lt;= <span class="number">57</span>;
  }

  <span class="function"><span class="keyword">function</span> <span class="title">isHexDigit</span><span class="params">(char)</span> {</span>
    <span class="keyword">return</span> (char &gt;= <span class="number">48</span> &amp;&amp; char &lt;= <span class="number">57</span>) || (char &gt;= <span class="number">97</span> &amp;&amp; char &lt;= <span class="number">102</span>) || (char &gt;= <span class="number">65</span> &amp;&amp; char &lt;= <span class="number">70</span>);
  }

</pre></div>             </td>           </tr>                               <tr id="section-73">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-73">&#182;</a>               </div>               <p>From <a href="http://www.lua.org/manual/5.2/manual.html#8.1">Lua 5.2</a> onwards
identifiers cannot use locale-dependet letters.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">isIdentifierStart</span><span class="params">(char)</span> {</span>
    <span class="keyword">return</span> (char &gt;= <span class="number">65</span> &amp;&amp; char &lt;= <span class="number">90</span>) || (char &gt;= <span class="number">97</span> &amp;&amp; char &lt;= <span class="number">122</span>) || <span class="number">95</span> === char;
  }

  <span class="function"><span class="keyword">function</span> <span class="title">isIdentifierPart</span><span class="params">(char)</span> {</span>
    <span class="keyword">return</span> (char &gt;= <span class="number">65</span> &amp;&amp; char &lt;= <span class="number">90</span>) || (char &gt;= <span class="number">97</span> &amp;&amp; char &lt;= <span class="number">122</span>) || <span class="number">95</span> === char || (char &gt;= <span class="number">48</span> &amp;&amp; char &lt;= <span class="number">57</span>);
  }

</pre></div>             </td>           </tr>                               <tr id="section-74">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-74">&#182;</a>               </div>               <p><a href="http://www.lua.org/manual/5.2/manual.html#3.1">3.1 Lexical Conventions</a></p>

<p><code>true</code>, <code>false</code> and <code>nil</code> will not be considered keywords, but literals.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">isKeyword</span><span class="params">(id)</span> {</span>
    <span class="keyword">switch</span> (id.length) {
      <span class="keyword">case</span> <span class="number">2</span>:
        <span class="keyword">return</span> <span class="string">'do'</span> === id || <span class="string">'if'</span> === id || <span class="string">'in'</span> === id || <span class="string">'or'</span> === id;
      <span class="keyword">case</span> <span class="number">3</span>:
        <span class="keyword">return</span> <span class="string">'and'</span> === id || <span class="string">'end'</span> === id || <span class="string">'for'</span> === id || <span class="string">'not'</span> === id;
      <span class="keyword">case</span> <span class="number">4</span>:
        <span class="keyword">return</span> <span class="string">'else'</span> === id || <span class="string">'goto'</span> === id || <span class="string">'then'</span> === id;
      <span class="keyword">case</span> <span class="number">5</span>:
        <span class="keyword">return</span> <span class="string">'break'</span> === id || <span class="string">'local'</span> === id || <span class="string">'until'</span> === id || <span class="string">'while'</span> === id;
      <span class="keyword">case</span> <span class="number">6</span>:
        <span class="keyword">return</span> <span class="string">'elseif'</span> === id || <span class="string">'repeat'</span> === id || <span class="string">'return'</span> === id;
      <span class="keyword">case</span> <span class="number">8</span>:
        <span class="keyword">return</span> <span class="string">'function'</span> === id;
    }
    <span class="keyword">return</span> <span class="literal">false</span>;
  }

  <span class="function"><span class="keyword">function</span> <span class="title">isUnary</span><span class="params">(token)</span> {</span>
    <span class="keyword">if</span> (Punctuator === token.type) <span class="keyword">return</span> ~<span class="string">'#-'</span>.indexOf(token.value);
    <span class="keyword">if</span> (Keyword === token.type) <span class="keyword">return</span> <span class="string">'not'</span> === token.value;
    <span class="keyword">return</span> <span class="literal">false</span>;
  }

</pre></div>             </td>           </tr>                               <tr id="section-75">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-75">&#182;</a>               </div>               <p>@TODO this needs to be rethought.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">isCallExpression</span><span class="params">(expression)</span> {</span>
    <span class="keyword">switch</span> (expression.type) {
      <span class="keyword">case</span> <span class="string">'CallExpression'</span>:
      <span class="keyword">case</span> <span class="string">'TableCallExpression'</span>:
      <span class="keyword">case</span> <span class="string">'StringCallExpression'</span>:
        <span class="keyword">return</span> <span class="literal">true</span>;
    }
    <span class="keyword">return</span> <span class="literal">false</span>;
  }

</pre></div>             </td>           </tr>                               <tr id="section-76">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-76">&#182;</a>               </div>               <p>Check if the token syntactically closes a block.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">isBlockFollow</span><span class="params">(token)</span> {</span>
    <span class="keyword">if</span> (EOF === token.type) <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span> (Keyword !== token.type) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">switch</span> (token.value) {
      <span class="keyword">case</span> <span class="string">'else'</span>: <span class="keyword">case</span> <span class="string">'elseif'</span>:
      <span class="keyword">case</span> <span class="string">'end'</span>: <span class="keyword">case</span> <span class="string">'until'</span>:
        <span class="keyword">return</span> <span class="literal">true</span>;
      <span class="keyword">default</span>:
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
  }

</pre></div>             </td>           </tr>                               <tr id="section-77">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-77">&#182;</a>               </div>               <h2>Scope</h2>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="keyword">var</span> scopes, scopeDepth;

</pre></div>             </td>           </tr>                               <tr id="section-78">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-78">&#182;</a>               </div>               <p>Create a new scope inheriting all declarations from the previous scope.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">createScope</span><span class="params">()</span> {</span>
    scopes.push(Array.apply(<span class="literal">null</span>, scopes[scopeDepth++]));
  }

</pre></div>             </td>           </tr>                               <tr id="section-79">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-79">&#182;</a>               </div>               <p>Exit and remove the current scope.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">exitScope</span><span class="params">()</span> {</span>
    scopes.pop();
    scopeDepth--;
  }

</pre></div>             </td>           </tr>                               <tr id="section-80">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-80">&#182;</a>               </div>               <p>Add identifier name to the current scope.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">scopeIdentifierName</span><span class="params">(name)</span> {</span>
    scopes[scopeDepth].push(name);
  }

</pre></div>             </td>           </tr>                               <tr id="section-81">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-81">&#182;</a>               </div>               <p>Add identifier to the current scope</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">scopeIdentifier</span><span class="params">(node)</span> {</span>
    scopeIdentifierName(node.name);
    node.isLocal = <span class="literal">true</span>;
  }

</pre></div>             </td>           </tr>                               <tr id="section-82">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-82">&#182;</a>               </div>               <p>Is the identifier name available in this scope.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">scopeHasName</span><span class="params">(name)</span> {</span>
    <span class="keyword">return</span> (-<span class="number">1</span> !== indexOf.call(scopes[scopeDepth], name));
  }


</pre></div>             </td>           </tr>                               <tr id="section-83">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-83">&#182;</a>               </div>               <h2>Parse functions</h2>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-84">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-84">&#182;</a>               </div>               <p>Chunk is the main program object. Syntactically it's the same as a block.</p>

<pre><code>chunk ::= block
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseChunk</span><span class="params">()</span> {</span>
    next();
    <span class="keyword">var</span> body = parseBlock();
    <span class="keyword">if</span> (EOF !== token.type) unexpected(token);
    <span class="keyword">return</span> ast.chunk(body);
  }

</pre></div>             </td>           </tr>                               <tr id="section-85">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-85">&#182;</a>               </div>               <p>A block contains a list of statements with an optional return statement
as its last statement.</p>

<pre><code>block ::= {stat} [retstat]
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseBlock</span><span class="params">(terminator)</span> {</span>
    <span class="keyword">var</span> block = []
      , statement;

</pre></div>             </td>           </tr>                               <tr id="section-86">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-86">&#182;</a>               </div>               <p>Each block creates a new scope.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (options.scope) createScope();

    <span class="keyword">while</span> (!isBlockFollow(token)) {
</pre></div>             </td>           </tr>                               <tr id="section-87">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-87">&#182;</a>               </div>               <p>Return has to be the last statement in a block.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (<span class="string">'return'</span> === token.value) {
        block.push(parseStatement());
        <span class="keyword">break</span>;
      }
      statement = parseStatement();
</pre></div>             </td>           </tr>                               <tr id="section-88">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-88">&#182;</a>               </div>               <p>Statements are only added if they are returned, this allows us to
ignore some statements, such as EmptyStatement.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (statement) block.push(statement);
    }

    <span class="keyword">if</span> (options.scope) exitScope();
</pre></div>             </td>           </tr>                               <tr id="section-89">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-89">&#182;</a>               </div>               <p>Doesn't really need an ast node</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">return</span> block;
  }

</pre></div>             </td>           </tr>                               <tr id="section-90">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-90">&#182;</a>               </div>               <p>There are two types of statements, simple and compound.</p>

<pre><code>statement ::= break | goto | do | while | repeat | return
     | if | for | function | local | label | assignment
     | functioncall | ';'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseStatement</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (Keyword === token.type) {
      <span class="keyword">switch</span> (token.value) {
        <span class="keyword">case</span> <span class="string">'local'</span>:    next(); <span class="keyword">return</span> parseLocalStatement();
        <span class="keyword">case</span> <span class="string">'if'</span>:       next(); <span class="keyword">return</span> parseIfStatement();
        <span class="keyword">case</span> <span class="string">'return'</span>:   next(); <span class="keyword">return</span> parseReturnStatement();
        <span class="keyword">case</span> <span class="string">'function'</span>: next();
          <span class="keyword">var</span> name = parseFunctionName();
          <span class="keyword">return</span> parseFunctionDeclaration(name);
        <span class="keyword">case</span> <span class="string">'while'</span>:    next(); <span class="keyword">return</span> parseWhileStatement();
        <span class="keyword">case</span> <span class="string">'for'</span>:      next(); <span class="keyword">return</span> parseForStatement();
        <span class="keyword">case</span> <span class="string">'repeat'</span>:   next(); <span class="keyword">return</span> parseRepeatStatement();
        <span class="keyword">case</span> <span class="string">'break'</span>:    next(); <span class="keyword">return</span> parseBreakStatement();
        <span class="keyword">case</span> <span class="string">'do'</span>:       next(); <span class="keyword">return</span> parseDoStatement();
        <span class="keyword">case</span> <span class="string">'goto'</span>:     next(); <span class="keyword">return</span> parseGotoStatement();
      }
    }

    <span class="keyword">if</span> (Punctuator === token.type) {
      <span class="keyword">if</span> (consume(<span class="string">'::'</span>)) <span class="keyword">return</span> parseLabelStatement();
    }

</pre></div>             </td>           </tr>                               <tr id="section-91">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-91">&#182;</a>               </div>               <p>When a <code>;</code> is encounted, simply eat it without storing it.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (consume(<span class="string">';'</span>)) <span class="keyword">return</span>;

    <span class="keyword">return</span> parseAssignmentOrCallStatement();
  }

</pre></div>             </td>           </tr>                               <tr id="section-92">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-92">&#182;</a>               </div>               <h2>Statements</h2>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-93">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-93">&#182;</a>               </div>               <pre><code>label ::= '::' Name '::'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseLabelStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> name = token.value
      , label = parseIdentifier();

    <span class="keyword">if</span> (options.scope) {
      scopeIdentifierName(<span class="string">'::'</span> + name + <span class="string">'::'</span>);
      label.isLocal = <span class="literal">true</span>;
    }

    expect(<span class="string">'::'</span>);
    <span class="keyword">return</span> ast.labelStatement(label);
  }

</pre></div>             </td>           </tr>                               <tr id="section-94">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-94">&#182;</a>               </div>               <pre><code>break ::= 'break'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseBreakStatement</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> ast.breakStatement();
  }

</pre></div>             </td>           </tr>                               <tr id="section-95">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-95">&#182;</a>               </div>               <pre><code>goto ::= 'goto' Name
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseGotoStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> name = token.value
      , label = parseIdentifier();

    <span class="keyword">if</span> (options.scope) label.isLabel = scopeHasName(<span class="string">'::'</span> + name + <span class="string">'::'</span>);
    <span class="keyword">return</span> ast.gotoStatement(label);
  }

</pre></div>             </td>           </tr>                               <tr id="section-96">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-96">&#182;</a>               </div>               <pre><code>do ::= 'do' block 'end'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseDoStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> body = parseBlock();
    expect(<span class="string">'end'</span>);
    <span class="keyword">return</span> ast.doStatement(body);
  }

</pre></div>             </td>           </tr>                               <tr id="section-97">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-97">&#182;</a>               </div>               <pre><code>while ::= 'while' exp 'do' block 'end'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseWhileStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> condition = parseExpression();
    expect(<span class="string">'do'</span>);
    <span class="keyword">var</span> body = parseBlock();
    expect(<span class="string">'end'</span>);
    <span class="keyword">return</span> ast.whileStatement(condition, body);
  }

</pre></div>             </td>           </tr>                               <tr id="section-98">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-98">&#182;</a>               </div>               <pre><code>repeat ::= 'repeat' block 'until' exp
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseRepeatStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> body = parseBlock();
    expect(<span class="string">'until'</span>);
    <span class="keyword">var</span> condition = expectExpression(parseExpression());
    <span class="keyword">return</span> ast.repeatStatement(condition, body);
  }

</pre></div>             </td>           </tr>                               <tr id="section-99">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-99">&#182;</a>               </div>               <pre><code>retstat ::= 'return' [exp {',' exp}] [';']
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseReturnStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> expressions = [];

    <span class="keyword">if</span> (<span class="string">'end'</span> !== token.value) {
      <span class="keyword">var</span> expression = parseExpression();
      <span class="keyword">if</span> (<span class="literal">null</span> != expression) expressions.push(expression);
      <span class="keyword">while</span> (consume(<span class="string">','</span>)) {
        expression = expectExpression(parseExpression());
        expressions.push(expression);
      }
      consume(<span class="string">';'</span>); <span class="comment">// grammar tells us ; is optional here.</span>
    }
    <span class="keyword">return</span> ast.returnStatement(expressions);
  }

</pre></div>             </td>           </tr>                               <tr id="section-100">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-100">&#182;</a>               </div>               <pre><code>if ::= 'if' exp 'then' block {elif} ['else' block] 'end'
elif ::= 'elseif' exp 'then' block
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseIfStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> clauses = []
      , condition
      , body;

    condition = parseExpression();
    expect(<span class="string">'then'</span>);
    body = parseBlock();
    clauses.push(ast.ifClause(condition, body));

    <span class="keyword">while</span> (consume(<span class="string">'elseif'</span>)) {
      condition = parseExpression();
      expect(<span class="string">'then'</span>);
      body = parseBlock();
      clauses.push(ast.elseifClause(condition, body));
    }

    <span class="keyword">if</span> (consume(<span class="string">'else'</span>)) {
      body = parseBlock();
      clauses.push(ast.elseClause(body));
    }

    expect(<span class="string">'end'</span>);
    <span class="keyword">return</span> ast.ifStatement(clauses);
  }

</pre></div>             </td>           </tr>                               <tr id="section-101">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-101">&#182;</a>               </div>               <p>There are two types of for statements, generic and numeric.</p>

<pre><code>for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'
for ::= namelist 'in' explist 'do' block 'end'
namelist ::= Name {',' Name}
explist ::= exp {',' exp}
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseForStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> variable = parseIdentifier()
      , body;

</pre></div>             </td>           </tr>                               <tr id="section-102">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-102">&#182;</a>               </div>               <p>The start-identifier is local.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (options.scope) scopeIdentifier(variable);

</pre></div>             </td>           </tr>                               <tr id="section-103">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-103">&#182;</a>               </div>               <p>If the first expression is followed by a <code>=</code> punctuator, this is a
Numeric For Statement.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (consume(<span class="string">'='</span>)) {
</pre></div>             </td>           </tr>                               <tr id="section-104">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-104">&#182;</a>               </div>               <p>Start expression</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">var</span> start = expectExpression(parseExpression());
      expect(<span class="string">','</span>);
</pre></div>             </td>           </tr>                               <tr id="section-105">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-105">&#182;</a>               </div>               <p>End expression</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">var</span> end = expectExpression(parseExpression());
</pre></div>             </td>           </tr>                               <tr id="section-106">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-106">&#182;</a>               </div>               <p>Optional step expression</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">var</span> step = consume(<span class="string">','</span>) ? expectExpression(parseExpression()) : <span class="literal">null</span>;

      expect(<span class="string">'do'</span>);
      body = parseBlock();
      expect(<span class="string">'end'</span>);

      <span class="keyword">return</span> ast.forNumericStatement(variable, start, end, step, body);

</pre></div>             </td>           </tr>                               <tr id="section-107">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-107">&#182;</a>               </div>               <p>If not, it's a Generic For Statement</p>             </td>             <td class="code">               <div class="highlight"><pre>    } <span class="keyword">else</span> {
</pre></div>             </td>           </tr>                               <tr id="section-108">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-108">&#182;</a>               </div>               <p>The namelist can contain one or more identifiers.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">var</span> variables = [variable];
      <span class="keyword">while</span> (consume(<span class="string">','</span>)) {
        variable = parseIdentifier();
</pre></div>             </td>           </tr>                               <tr id="section-109">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-109">&#182;</a>               </div>               <p>Each variable in the namelist is locally scoped.</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="keyword">if</span> (options.scope) scopeIdentifier(variable);
        variables.push(variable);
      }
      expect(<span class="string">'in'</span>);
      <span class="keyword">var</span> iterators = [];

</pre></div>             </td>           </tr>                               <tr id="section-110">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-110">&#182;</a>               </div>               <p>One or more expressions in the explist.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">do</span> {
        <span class="keyword">var</span> expression = expectExpression(parseExpression());
        iterators.push(expression);
      } <span class="keyword">while</span> (consume(<span class="string">','</span>));

      expect(<span class="string">'do'</span>);
      body = parseBlock();
      expect(<span class="string">'end'</span>);

      <span class="keyword">return</span> ast.forGenericStatement(variables, iterators, body);
    }
  }

</pre></div>             </td>           </tr>                               <tr id="section-111">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-111">&#182;</a>               </div>               <p>Local statements can either be variable assignments or function
definitions. If a function definition is found, it will be delegated to
<code>parseFunctionDeclaration()</code> with the isLocal flag.</p>

<p>This AST structure might change into a local assignment with a function
child.</p>

<pre><code>local ::= 'local' 'function' Name funcdecl
   | 'local' Name {',' Name} ['=' exp {',' exp}
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseLocalStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> name;

    <span class="keyword">if</span> (Identifier === token.type) {
      <span class="keyword">var</span> variables = []
        , init = [];

      <span class="keyword">do</span> {
        name = parseIdentifier();

        variables.push(name);
      } <span class="keyword">while</span> (consume(<span class="string">','</span>));

      <span class="keyword">if</span> (consume(<span class="string">'='</span>)) {
        <span class="keyword">do</span> {
          <span class="keyword">var</span> expression = expectExpression(parseExpression());
          init.push(expression);
        } <span class="keyword">while</span> (consume(<span class="string">','</span>));
      }

</pre></div>             </td>           </tr>                               <tr id="section-112">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-112">&#182;</a>               </div>               <p>Declarations doesn't exist before the statement has been evaluated.
Therefore assignments can't use their declarator. And the identifiers
shouldn't be added to the scope until the statement is complete.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (options.scope) {
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = variables.length; i &lt; l; i++) {
          scopeIdentifier(variables[i]);
        }
      }

      <span class="keyword">return</span> ast.localStatement(variables, init);
    }
    <span class="keyword">if</span> (consume(<span class="string">'function'</span>)) {
      name = parseIdentifier();
      <span class="keyword">if</span> (options.scope) scopeIdentifier(name);

</pre></div>             </td>           </tr>                               <tr id="section-113">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-113">&#182;</a>               </div>               <p>MemberExpressions are not allowed in local function statements.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">return</span> parseFunctionDeclaration(name, <span class="literal">true</span>);
    } <span class="keyword">else</span> {
      raiseUnexpectedToken(<span class="string">'&lt;name&gt;'</span>, token);
    }
  }

</pre></div>             </td>           </tr>                               <tr id="section-114">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-114">&#182;</a>               </div>               <pre><code>assignment ::= varlist '=' explist
varlist ::= prefixexp {',' prefixexp}
explist ::= exp {',' exp}

call ::= callexp
callexp ::= prefixexp args | prefixexp ':' Name args
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseAssignmentOrCallStatement</span><span class="params">()</span> {</span>
</pre></div>             </td>           </tr>                               <tr id="section-115">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-115">&#182;</a>               </div>               <p>Keep a reference to the previous token for better error messages in case
of invalid statement</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">var</span> previous = token
      , expression = parsePrefixExpression();

    <span class="keyword">if</span> (<span class="literal">null</span> == expression) <span class="keyword">return</span> unexpected(token);
    <span class="keyword">if</span> (~<span class="string">',='</span>.indexOf(token.value)) {
      <span class="keyword">var</span> variables = [expression]
        , init = []
        , exp;

      <span class="keyword">while</span> (consume(<span class="string">','</span>)) {
        exp = expectExpression(parsePrefixExpression());
        variables.push(exp);
      }
      expect(<span class="string">'='</span>);
      <span class="keyword">do</span> {
        exp = expectExpression(parseExpression());
        init.push(exp);
      } <span class="keyword">while</span> (consume(<span class="string">','</span>));
      <span class="keyword">return</span> ast.assignmentStatement(variables, init);
    }
    <span class="keyword">if</span> (isCallExpression(expression)) {
      <span class="keyword">return</span> ast.callStatement(expression);
    }
</pre></div>             </td>           </tr>                               <tr id="section-116">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-116">&#182;</a>               </div>               <p>The prefix expression was neither part of an assignment or a
callstatement, however as it was valid it's been consumed, so raise
the exception on the previous token to provide a helpful message.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">return</span> unexpected(previous);
  }



</pre></div>             </td>           </tr>                               <tr id="section-117">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-117">&#182;</a>               </div>               <h3>Non-statements</h3>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-118">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-118">&#182;</a>               </div>               <pre><code>Identifier ::= Name
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseIdentifier</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> identifier = token.value;
    <span class="keyword">if</span> (Identifier !== token.type) raiseUnexpectedToken(<span class="string">'&lt;name&gt;'</span>, token);
    next();
    <span class="keyword">return</span> ast.identifier(identifier);
  }

</pre></div>             </td>           </tr>                               <tr id="section-119">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-119">&#182;</a>               </div>               <p>Parse the functions parameters and body block. The name should already
have been parsed and passed to this declaration function. By separating
this we allow for anonymous functions in expressions.</p>

<p>For local functions there's a boolean parameter which needs to be set
when parsing the declaration.</p>

<pre><code>funcdecl ::= '(' [parlist] ')' block 'end'
parlist ::= Name {',' Name} | [',' '...'] | '...'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseFunctionDeclaration</span><span class="params">(name, isLocal)</span> {</span>
    <span class="keyword">var</span> parameters = [];
    expect(<span class="string">'('</span>);

</pre></div>             </td>           </tr>                               <tr id="section-120">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-120">&#182;</a>               </div>               <p>The declaration has arguments</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (!consume(<span class="string">')'</span>)) {
</pre></div>             </td>           </tr>                               <tr id="section-121">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-121">&#182;</a>               </div>               <p>Arguments are a comma separated list of identifiers, optionally ending
with a vararg.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">while</span> (<span class="literal">true</span>) {
        <span class="keyword">if</span> (Identifier === token.type) {
          <span class="keyword">var</span> parameter = parseIdentifier();
</pre></div>             </td>           </tr>                               <tr id="section-122">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-122">&#182;</a>               </div>               <p>Function parameters are local.</p>             </td>             <td class="code">               <div class="highlight"><pre>          <span class="keyword">if</span> (options.scope) scopeIdentifier(parameter);

          parameters.push(parameter);

          <span class="keyword">if</span> (consume(<span class="string">','</span>)) <span class="keyword">continue</span>;
          <span class="keyword">else</span> <span class="keyword">if</span> (consume(<span class="string">')'</span>)) <span class="keyword">break</span>;
</pre></div>             </td>           </tr>                               <tr id="section-123">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-123">&#182;</a>               </div>               <p>No arguments are allowed after a vararg.</p>             </td>             <td class="code">               <div class="highlight"><pre>        } <span class="keyword">else</span> <span class="keyword">if</span> (VarargLiteral === token.type) {
          parameters.push(parsePrimaryExpression());
          expect(<span class="string">')'</span>);
          <span class="keyword">break</span>;
        } <span class="keyword">else</span> {
          raiseUnexpectedToken(<span class="string">'&lt;name&gt; or \'...\''</span>, token);
        }
      }
    }

    <span class="keyword">var</span> body = parseBlock();
    expect(<span class="string">'end'</span>);

    isLocal = isLocal || <span class="literal">false</span>;
    <span class="keyword">return</span> ast.functionStatement(name, parameters, isLocal, body);
  }

</pre></div>             </td>           </tr>                               <tr id="section-124">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-124">&#182;</a>               </div>               <p>Parse the function name as identifiers and member expressions.</p>

<pre><code>Name {'.' Name} [':' Name]
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseFunctionName</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> base = parseIdentifier()
      , name;
    <span class="keyword">if</span> (options.scope) base.isLocal = <span class="literal">false</span>;

    <span class="keyword">while</span> (consume(<span class="string">'.'</span>)) {
      name = parseIdentifier();
      <span class="keyword">if</span> (options.scope) name.isLocal = <span class="literal">false</span>;
      base = ast.memberExpression(base, <span class="string">'.'</span>, name);
    }

    <span class="keyword">if</span> (consume(<span class="string">':'</span>)) {
      name = parseIdentifier();
      <span class="keyword">if</span> (options.scope) name.isLocal = <span class="literal">false</span>;
      base = ast.memberExpression(base, <span class="string">':'</span>, name);
    }

    <span class="keyword">return</span> base;
  }

</pre></div>             </td>           </tr>                               <tr id="section-125">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-125">&#182;</a>               </div>               <pre><code>tableconstructor ::= '{' [fieldlist] '}'
fieldlist ::= field {fieldsep field} fieldsep
field ::= '[' exp ']' '=' exp | Name = 'exp' | exp

fieldsep ::= ',' | ';'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseTableConstructor</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> fields = []
      , key, value;

    <span class="keyword">while</span> (<span class="literal">true</span>) {
      <span class="keyword">if</span> (Punctuator === token.type &amp;&amp; consume(<span class="string">'['</span>)) {
        key = parseExpression();
        expect(<span class="string">']'</span>);
        expect(<span class="string">'='</span>);
        value = expectExpression(parseExpression());
        fields.push(ast.tableKey(key, value));
      } <span class="keyword">else</span> <span class="keyword">if</span> (Identifier === token.type) {
        key = parseExpression();
        <span class="keyword">if</span> (consume(<span class="string">'='</span>)) {
          value = parseExpression();
          fields.push(ast.tableKeyString(key, value));
        } <span class="keyword">else</span> {
          fields.push(ast.tableValue(key));
        }
      } <span class="keyword">else</span> {
        <span class="keyword">if</span> (<span class="literal">null</span> == (value = parseExpression())) <span class="keyword">break</span>;
        fields.push(ast.tableValue(value));
      }
      <span class="keyword">if</span> (~<span class="string">',;'</span>.indexOf(token.value)) {
        next();
        <span class="keyword">continue</span>;
      }
      <span class="keyword">if</span> (<span class="string">'}'</span> === token.value) <span class="keyword">break</span>;
    }
    expect(<span class="string">'}'</span>);
    <span class="keyword">return</span> ast.tableConstructorExpression(fields);
  }

</pre></div>             </td>           </tr>                               <tr id="section-126">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-126">&#182;</a>               </div>               <h2>Expression parser</h2>

<p>Expressions are evaluated and always return a value.</p>

<pre><code>exp ::= (unop exp | primary | prefixexp ) { binop exp }

primary ::= nil | false | true | Number | String | '...'
     | functiondef | tableconstructor

prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'
     | '.' Name | ':' Name args | args }
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseExpression</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> expression = parseSubExpression(<span class="number">0</span>);
    <span class="keyword">return</span> expression;
  }

</pre></div>             </td>           </tr>                               <tr id="section-127">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-127">&#182;</a>               </div>               <p>Return the precedence priority of the operator.</p>

<p>As unary <code>-</code> can't be distinguished from binary <code>-</code>, unary precedence
isn't described in this table but in <code>parseSubExpression()</code> itself.</p>

<p>As this function gets hit on every expression it's been optimized due to
the expensive CompareICStub which took ~8% of the parse time.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">binaryPrecedence</span><span class="params">(operator)</span> {</span>
    <span class="keyword">var</span> char = operator.charCodeAt(<span class="number">0</span>)
      , length = operator.length;

    <span class="keyword">if</span> (<span class="number">1</span> === length) {
      <span class="keyword">switch</span> (char) {
        <span class="keyword">case</span> <span class="number">94</span>: <span class="keyword">return</span> <span class="number">10</span>; <span class="comment">// ^</span>
        <span class="keyword">case</span> <span class="number">42</span>: <span class="keyword">case</span> <span class="number">47</span>: <span class="keyword">case</span> <span class="number">37</span>: <span class="keyword">return</span> <span class="number">7</span>; <span class="comment">// * / %</span>
        <span class="keyword">case</span> <span class="number">43</span>: <span class="keyword">case</span> <span class="number">45</span>: <span class="keyword">return</span> <span class="number">6</span>; <span class="comment">// + -</span>
        <span class="keyword">case</span> <span class="number">60</span>: <span class="keyword">case</span> <span class="number">62</span>: <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// &lt; &gt;</span>
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> === length) {
      <span class="keyword">switch</span> (char) {
        <span class="keyword">case</span> <span class="number">46</span>: <span class="keyword">return</span> <span class="number">5</span>; <span class="comment">// ..</span>
        <span class="keyword">case</span> <span class="number">60</span>: <span class="keyword">case</span> <span class="number">62</span>: <span class="keyword">case</span> <span class="number">61</span>: <span class="keyword">case</span> <span class="number">126</span>: <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// &lt;= &gt;= == ~=</span>
        <span class="keyword">case</span> <span class="number">111</span>: <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// or</span>
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">97</span> === char &amp;&amp; <span class="string">'and'</span> === operator) <span class="keyword">return</span> <span class="number">2</span>;
    <span class="keyword">return</span> <span class="number">0</span>;
  }

</pre></div>             </td>           </tr>                               <tr id="section-128">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-128">&#182;</a>               </div>               <p>Implement an operator-precedence parser to handle binary operator
precedence.</p>

<p>We use this algorithm because it's compact, it's fast and Lua core uses
the same so we can be sure our expressions are parsed in the same manner
without excessive amounts of tests.</p>

<pre><code>exp ::= (unop exp | primary | prefixexp ) { binop exp }
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseSubExpression</span><span class="params">(minPrecedence)</span> {</span>
    <span class="keyword">var</span> operator = token.value;
</pre></div>             </td>           </tr>                               <tr id="section-129">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-129">&#182;</a>               </div>               <p>The left-hand side in binary operations.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">var</span> expression;

</pre></div>             </td>           </tr>                               <tr id="section-130">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-130">&#182;</a>               </div>               <p>UnaryExpression</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (isUnary(token)) {
      next();
      <span class="keyword">var</span> argument = expectExpression(parseSubExpression(<span class="number">8</span>));
      expression = ast.unaryExpression(operator, argument);
    }
    <span class="keyword">if</span> (<span class="literal">null</span> == expression) {
</pre></div>             </td>           </tr>                               <tr id="section-131">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-131">&#182;</a>               </div>               <p>PrimaryExpression</p>             </td>             <td class="code">               <div class="highlight"><pre>      expression = parsePrimaryExpression();

</pre></div>             </td>           </tr>                               <tr id="section-132">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-132">&#182;</a>               </div>               <p>PrefixExpression</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (<span class="literal">null</span> == expression) {
        expression = parsePrefixExpression();
      }
    }
</pre></div>             </td>           </tr>                               <tr id="section-133">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-133">&#182;</a>               </div>               <p>This is not a valid left hand expression.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (<span class="literal">null</span> == expression) <span class="keyword">return</span> <span class="literal">null</span>;

    <span class="keyword">var</span> precedence;
    <span class="keyword">while</span> (<span class="literal">true</span>) {
      operator = token.value;

      precedence = (Punctuator === token.type || Keyword === token.type) ?
        binaryPrecedence(operator) : <span class="number">0</span>;

      <span class="keyword">if</span> (precedence === <span class="number">0</span> || precedence &lt;= minPrecedence) <span class="keyword">break</span>;
</pre></div>             </td>           </tr>                               <tr id="section-134">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-134">&#182;</a>               </div>               <p>Right-hand precedence operators</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (<span class="string">'^'</span> === operator || <span class="string">'..'</span> === operator) precedence--;
      next();
      <span class="keyword">var</span> right = expectExpression(parseSubExpression(precedence));
      expression = ast.binaryExpression(operator, expression, right);
    }
    <span class="keyword">return</span> expression;
  }

</pre></div>             </td>           </tr>                               <tr id="section-135">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-135">&#182;</a>               </div>               <pre><code>prefixexp ::= prefix {suffix}
prefix ::= Name | '(' exp ')'
suffix ::= '[' exp ']' | '.' Name | ':' Name args | args

args ::= '(' [explist] ')' | tableconstructor | String
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parsePrefixExpression</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> base, name
</pre></div>             </td>           </tr>                               <tr id="section-136">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-136">&#182;</a>               </div>               <p>Keep track of the scope, if a parent is local so are the children.</p>             </td>             <td class="code">               <div class="highlight"><pre>      , isLocal;

</pre></div>             </td>           </tr>                               <tr id="section-137">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-137">&#182;</a>               </div>               <p>The prefix</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (Identifier === token.type) {
      name = token.value;
      base = parseIdentifier();
</pre></div>             </td>           </tr>                               <tr id="section-138">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-138">&#182;</a>               </div>               <p>Set the parent scope.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (options.scope) base.isLocal = isLocal = scopeHasName(name);
    } <span class="keyword">else</span> <span class="keyword">if</span> (consume(<span class="string">'('</span>)) {
      base = expectExpression(parseExpression());
      expect(<span class="string">')'</span>);
      <span class="keyword">if</span> (options.scope) isLocal = base.isLocal;
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> <span class="literal">null</span>;
    }

</pre></div>             </td>           </tr>                               <tr id="section-139">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-139">&#182;</a>               </div>               <p>The suffix</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">var</span> expression, identifier;
    <span class="keyword">while</span> (<span class="literal">true</span>) {
      expectExpression(base);
      <span class="keyword">if</span> (Punctuator === token.type) {
        <span class="keyword">switch</span> (token.value) {
          <span class="keyword">case</span> <span class="string">'['</span>:
            next();
            expression = parseExpression();
            base = ast.indexExpression(base, expression);
            expect(<span class="string">']'</span>);
            <span class="keyword">break</span>;
          <span class="keyword">case</span> <span class="string">'.'</span>:
            next();
            identifier = parseIdentifier();
</pre></div>             </td>           </tr>                               <tr id="section-140">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-140">&#182;</a>               </div>               <p>Inherit the scope</p>             </td>             <td class="code">               <div class="highlight"><pre>            <span class="keyword">if</span> (options.scope) identifier.isLocal = isLocal;
            base = ast.memberExpression(base, <span class="string">'.'</span>, identifier);
            <span class="keyword">break</span>;
          <span class="keyword">case</span> <span class="string">':'</span>:
            next();
            identifier = parseIdentifier();
            <span class="keyword">if</span> (options.scope) identifier.isLocal = isLocal;
            base = ast.memberExpression(base, <span class="string">':'</span>, identifier);
</pre></div>             </td>           </tr>                               <tr id="section-141">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-141">&#182;</a>               </div>               <p>Once a : is found, this has to be a callexpression, otherwise
throw an error.</p>             </td>             <td class="code">               <div class="highlight"><pre>            base = parseCallExpression(base);
            <span class="keyword">break</span>;
          <span class="keyword">case</span> <span class="string">'('</span>: <span class="keyword">case</span> <span class="string">'{'</span>: <span class="comment">// args</span>
            base = parseCallExpression(base);
            <span class="keyword">break</span>;
          <span class="keyword">default</span>:
            <span class="keyword">return</span> base;
        }
      } <span class="keyword">else</span> <span class="keyword">if</span> (StringLiteral === token.type) {
        base = parseCallExpression(base);
      } <span class="keyword">else</span> {
        <span class="keyword">break</span>;
      }
    }

    <span class="keyword">return</span> base;
  }

</pre></div>             </td>           </tr>                               <tr id="section-142">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-142">&#182;</a>               </div>               <pre><code>args ::= '(' [explist] ')' | tableconstructor | String
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseCallExpression</span><span class="params">(base)</span> {</span>
    <span class="keyword">if</span> (Punctuator === token.type) {
      <span class="keyword">switch</span> (token.value) {
        <span class="keyword">case</span> <span class="string">'('</span>:
          next();

</pre></div>             </td>           </tr>                               <tr id="section-143">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-143">&#182;</a>               </div>               <p>List of expressions</p>             </td>             <td class="code">               <div class="highlight"><pre>          <span class="keyword">var</span> expressions = [];
          <span class="keyword">var</span> expression = parseExpression();
          <span class="keyword">if</span> (<span class="literal">null</span> != expression) expressions.push(expression);
          <span class="keyword">while</span> (consume(<span class="string">','</span>)) {
            expression = expectExpression(parseExpression());
            expressions.push(expression);
          }

          expect(<span class="string">')'</span>);
          <span class="keyword">return</span> ast.callExpression(base, expressions);

        <span class="keyword">case</span> <span class="string">'{'</span>:
          next();
          <span class="keyword">var</span> table = parseTableConstructor();
          <span class="keyword">return</span> ast.tableCallExpression(base, table);
      }

    } <span class="keyword">else</span> <span class="keyword">if</span> (StringLiteral === token.type) {
      <span class="keyword">return</span> ast.stringCallExpression(base, parsePrimaryExpression());
    }

    raiseUnexpectedToken(<span class="string">'function arguments'</span>, token);
  }

</pre></div>             </td>           </tr>                               <tr id="section-144">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-144">&#182;</a>               </div>               <pre><code>primary ::= String | Numeric | nil | true | false
     | functiondef | tableconstructor | '...'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parsePrimaryExpression</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral
      , value = token.value
      , type = token.type;

    <span class="keyword">if</span> (type &amp; literals) {
      <span class="keyword">var</span> raw = input.slice(token.range[<span class="number">0</span>], token.range[<span class="number">1</span>]);
      next();
      <span class="keyword">return</span> ast.literal(type, value, raw);
    } <span class="keyword">else</span> <span class="keyword">if</span> (Keyword === type &amp;&amp; <span class="string">'function'</span> === value) {
      next();
      <span class="keyword">return</span> parseFunctionDeclaration(<span class="literal">null</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (consume(<span class="string">'{'</span>))
      <span class="keyword">return</span> parseTableConstructor();
  }

</pre></div>             </td>           </tr>                               <tr id="section-145">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-145">&#182;</a>               </div>               <h2>Parser</h2>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-146">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-146">&#182;</a>               </div>               <p>Export the main parser.</p>

<ul>
<li><code>wait</code> Hold parsing until end() is called. Defaults to false</li>
</ul>

<p>Example:</p>

<pre><code>var parser = require('luaparser');
parser.parse('i = 0');
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  exports.parse = parse;

  <span class="function"><span class="keyword">function</span> <span class="title">parse</span><span class="params">(_input, _options)</span> {</span>
    <span class="keyword">if</span> (<span class="string">'undefined'</span> === <span class="keyword">typeof</span> _options &amp;&amp; <span class="string">'object'</span> === <span class="keyword">typeof</span> _input) {
      _options = _input;
      _input = <span class="literal">undefined</span>;
    }
    <span class="keyword">if</span> (!_options) _options = {};

    input = _input || <span class="string">''</span>;
    options = extend(defaultOptions, _options);

</pre></div>             </td>           </tr>                               <tr id="section-147">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-147">&#182;</a>               </div>               <p>Rewind the lexer</p>             </td>             <td class="code">               <div class="highlight"><pre>    index = <span class="number">0</span>;
    line = <span class="number">1</span>;
    lineStart = <span class="number">0</span>;
    length = input.length;
</pre></div>             </td>           </tr>                               <tr id="section-148">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-148">&#182;</a>               </div>               <p>When tracking identifier scope, initialize with an empty scope.</p>             </td>             <td class="code">               <div class="highlight"><pre>    scopes = [[]];
    scopeDepth = <span class="number">0</span>;

    <span class="keyword">if</span> (options.comments) comments = [];
    <span class="keyword">if</span> (!options.wait) <span class="keyword">return</span> end();
    <span class="keyword">return</span> exports;
  }

</pre></div>             </td>           </tr>                               <tr id="section-149">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-149">&#182;</a>               </div>               <p>Write to the source code buffer without beginning the parse.</p>             </td>             <td class="code">               <div class="highlight"><pre>  exports.write = write;

  <span class="function"><span class="keyword">function</span> <span class="title">write</span><span class="params">(_input)</span> {</span>
    input += String(_input);
    length = input.length;
    <span class="keyword">return</span> exports;
  }

</pre></div>             </td>           </tr>                               <tr id="section-150">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-150">&#182;</a>               </div>               <p>Send an EOF and begin parsing.</p>             </td>             <td class="code">               <div class="highlight"><pre>  exports.end = end;

  <span class="function"><span class="keyword">function</span> <span class="title">end</span><span class="params">(_input)</span> {</span>
    <span class="keyword">if</span> (<span class="string">'undefined'</span> !== <span class="keyword">typeof</span> _input) write(_input);

    length = input.length;
</pre></div>             </td>           </tr>                               <tr id="section-151">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-151">&#182;</a>               </div>               <p>Initialize with a lookahead token.</p>             </td>             <td class="code">               <div class="highlight"><pre>    lookahead = readToken();

    <span class="keyword">var</span> chunk = parseChunk();
    <span class="keyword">if</span> (options.comments) chunk.comments = comments;
    <span class="keyword">return</span> chunk;
  }

</pre></div>             </td>           </tr>                               <tr id="section-152">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-152">&#182;</a>               </div>               <p>Expose the lex function</p>             </td>             <td class="code">               <div class="highlight"><pre>  exports.lex = readToken;

}));
<span class="comment">/* vim: set sw=2 ts=2 et tw=79 : */</span>

</pre></div>             </td>           </tr>                </tbody>     </table>   </div> </body> </html> 