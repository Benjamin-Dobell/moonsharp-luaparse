<!DOCTYPE html>  <html> <head>   <title>luaparse.js</title>   <meta http-equiv="content-type" content="text/html; charset=UTF-8">   <link rel="stylesheet" media="all" href="docco.css" /> </head> <body>   <div id="container">     <div id="background"></div>          <table cellpadding="0" cellspacing="0">       <thead>         <tr>           <th class="docs">             <h1>               luaparse.js             </h1>           </th>           <th class="code">           </th>         </tr>       </thead>       <tbody>                               <tr id="section-1">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-1">&#182;</a>               </div>                            </td>             <td class="code">               <div class="highlight"><pre><span class="comment">/*global exports:true require:true define:true console:true */</span>

(<span class="function"><span class="keyword">function</span> <span class="params">(root, name, factory)</span> {</span>
  <span class="string">'use strict'</span>;

  <span class="keyword">if</span> (<span class="keyword">typeof</span> exports !== <span class="string">'undefined'</span>) {
    factory(exports);
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) {
    define([<span class="string">'exports'</span>], factory);
  } <span class="keyword">else</span> {
    factory((root[name] = {}));
  }
}(<span class="keyword">this</span>, <span class="string">'luaparse'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(exports)</span> {</span>
  <span class="string">'use strict'</span>;

  exports.version = <span class="string">'0.0.1'</span>;

  <span class="keyword">var</span> input, options, length;

  <span class="keyword">var</span> defaultOptions = exports.defaultOptions = {
</pre></div>             </td>           </tr>                               <tr id="section-2">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-2">&#182;</a>               </div>               <p>Explicitly tell the parser when the input ends.</p>             </td>             <td class="code">               <div class="highlight"><pre>      wait: <span class="literal">false</span>
</pre></div>             </td>           </tr>                               <tr id="section-3">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-3">&#182;</a>               </div>               <p>Store comments as an array in the chunk object.</p>             </td>             <td class="code">               <div class="highlight"><pre>    , comments: <span class="literal">true</span>
</pre></div>             </td>           </tr>                               <tr id="section-4">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-4">&#182;</a>               </div>               <p>Keep track of node locations.</p>             </td>             <td class="code">               <div class="highlight"><pre>    , location: <span class="literal">true</span>
  };

  <span class="keyword">var</span> Tokens = exports.Tokens = {
      EOF: <span class="number">0</span>
    , StringLiteral: <span class="number">1</span>
    , Keyword: <span class="number">2</span>
    , Identifier: <span class="number">3</span>
    , NumericLiteral: <span class="number">4</span>
    , Punctuator: <span class="number">5</span>
    , BooleanLiteral: <span class="number">6</span>
    , NilLiteral: <span class="number">7</span>
    , DotsLiteral: <span class="number">8</span>
  };

  <span class="keyword">var</span> TokenName = exports.TokenName = {};
  TokenName[Tokens.EOF] = <span class="string">'&lt;eof&gt;'</span>;
  TokenName[Tokens.StringLiteral] = <span class="string">'string'</span>;
  TokenName[Tokens.Keyword] = <span class="string">'keyword'</span>;
  TokenName[Tokens.Identifier] = <span class="string">'identifier'</span>;
  TokenName[Tokens.NumericLiteral] = <span class="string">'number'</span>;
  TokenName[Tokens.Punctuator] = <span class="string">'symbol'</span>;
  TokenName[Tokens.BooleanLiteral] = <span class="string">'boolean'</span>;
  TokenName[Tokens.NilLiteral] = <span class="string">'nil'</span>;
  TokenName[Tokens.DotsLiteral] = <span class="string">'\'...\''</span>;

</pre></div>             </td>           </tr>                               <tr id="section-5">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-5">&#182;</a>               </div>               <p>As this parser is a bit different from luas own, the error messages
will be different in some situations.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="keyword">var</span> errors = exports.errors = {
      unexpectedSymbol: <span class="string">'Unexpected symbol \'%1\' near \'%2\''</span>
    , unexpected: <span class="string">'Unexpected %1 \'%2\' near \'%3\''</span>
    , expected: <span class="string">'\'%1\' expected near \'%2\''</span>
    , expectedToken: <span class="string">'%1 expected near \'%2\''</span>
    , unfinishedString: <span class="string">'unfinished string near \'%1\''</span>
    , malformedNumber: <span class="string">'malformed number near \'%1\''</span>
  };

</pre></div>             </td>           </tr>                               <tr id="section-6">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-6">&#182;</a>               </div>               <p>Regular expression matches exposed for modification.
<em>These will most likely be optimized into procedural functions later.</em></p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="keyword">var</span> regexp = exports.regexp = {
      decDigit: <span class="regexp">/^[0-9]$/</span>
    , hexDigit: <span class="regexp">/^[0-9a-fA-F]$/</span>
    , whiteSpace: <span class="regexp">/^[ \t\u000B\u000C\u0020]$/</span>
    , lineTerminator: <span class="regexp">/^[\n\r]$/</span>
    , identifierStart: <span class="regexp">/^[a-zA-Z_]$/</span>
    , identifierPart: <span class="regexp">/^[a-zA-Z0-9_]$/</span>
  };

</pre></div>             </td>           </tr>                               <tr id="section-7">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-7">&#182;</a>               </div>               <h3>Abstract Syntax Tree</h3>

<p>The default AST structure resembles the Mozilla Parser API but can easily
be changed by overriding these functions.
<em>Due to the insignificant call count these functions won't get inlined by
V8.</em></p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="keyword">var</span> ast = exports.ast = {
      labelStatement: <span class="keyword">function</span>(label) {
      <span class="keyword">return</span> {
          type: <span class="string">'LabelStatement'</span>
        , label: label
      };
    }

    , breakStatement: <span class="keyword">function</span>() {
      <span class="keyword">return</span> {
          type: <span class="string">'BreakStatement'</span>
      };
    }

    , gotoStatement: <span class="keyword">function</span>(label) {
      <span class="keyword">return</span> {
          type: <span class="string">'GotoStatement'</span>
        , label: label
      };
    }

    , returnStatement: <span class="keyword">function</span>(args) {
      <span class="keyword">return</span> {
          type: <span class="string">'ReturnStatement'</span>
        , <span class="string">'arguments'</span>: args <span class="comment">// @TODO list?</span>
      };
    }

    , ifStatement: <span class="keyword">function</span>(clauses) {
      <span class="keyword">return</span> {
          type: <span class="string">'IfStatement'</span>
        , clauses: clauses
      };
    }

    , whileStatement: <span class="keyword">function</span>(condition, body) {
      <span class="keyword">return</span> {
          type: <span class="string">'WhileStatement'</span>
        , condition: condition
        , body: body
      };
    }

    , doStatement: <span class="keyword">function</span>(body) {
      <span class="keyword">return</span> {
          type: <span class="string">'DoStatement'</span>
        , body: body
      };
    }

    , repeatStatement: <span class="keyword">function</span>(condition, body) {
      <span class="keyword">return</span> {
          type: <span class="string">'RepeatStatement'</span>
        , condition: condition
        , body: body
      };
    }

    , localStatement: <span class="keyword">function</span>(variables, init) {
      <span class="keyword">return</span> {
          type: <span class="string">'LocalStatement'</span>
        , variables: variables
        , init: init
      };
    }

    , assignmentStatement: <span class="keyword">function</span>(variables, init) {
      <span class="keyword">return</span> {
          type: <span class="string">'AssignmentStatement'</span>
        , variables: variables
        , init: init
      };
    }

    , callStatement: <span class="keyword">function</span>(expression) {
      <span class="keyword">return</span> {
          type: <span class="string">'CallStatement'</span>
        , expression: expression
      };
    }

</pre></div>             </td>           </tr>                               <tr id="section-8">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-8">&#182;</a>               </div>               <p>@TODO this structure seems a bit too complicated to be honest. Maybe we
should separate local as a wrapper like CallStatement?</p>

<blockquote>
  <p>Vararg expressions, denoted by three dots ('...'), can only be used
  when directly inside a vararg function (3.4 - Expressions)</p>
</blockquote>             </td>             <td class="code">               <div class="highlight"><pre>
    , functionStatement: <span class="keyword">function</span>(identifier, parameters, isVararg, isLocal, body) {
      <span class="keyword">return</span> {
          type: <span class="string">'FunctionDeclaration'</span>
        , identifier: identifier
        , vararg: isVararg
        , local: isLocal
        , parameters: parameters
        , body: body
      };
    }

    , forNumericStatement: <span class="keyword">function</span>(variable, start, end, step, body) {
      <span class="keyword">return</span> {
          type: <span class="string">'ForNumericStatement'</span>
        , variable: variable
        , start: start
        , end: end
        , step: step
        , body: body
      };
    }

    , forGenericStatement: <span class="keyword">function</span>(variables, iterators, body) {
      <span class="keyword">return</span> {
          type: <span class="string">'ForGenericStatement'</span>
        , variables: variables
        , iterators: iterators <span class="comment">// @TODO is iterators a proper name?</span>
        , body: body
      };
    }

    , chunk: <span class="keyword">function</span>(body) {
      <span class="keyword">return</span> {
          type: <span class="string">'Chunk'</span>
        , body: body
      };
    }

    , clause: <span class="keyword">function</span>(condition, body) {
      <span class="keyword">return</span> {
          condition: condition
        , body: body
      };
    }

    , identifier: <span class="keyword">function</span>(name) {
      <span class="keyword">return</span> {
          type: <span class="string">'Identifier'</span>
        , name: name
      };
    }

    , literal: <span class="keyword">function</span>(value) {
      <span class="keyword">return</span> {
          type: <span class="string">'Literal'</span>
        , value: value
      };
    }
    , varargLiteral: <span class="keyword">function</span>() {
      <span class="keyword">return</span> {
          type: <span class="string">'VarargLiteral'</span>
      };
    }
    , tableConstructorExpression: <span class="keyword">function</span>(fields) {
      <span class="keyword">return</span> {
          type: <span class="string">'TableConstructorExpression'</span>
        , fields: fields
      };
    }
    , tableKey: <span class="keyword">function</span>(key, value) {
      <span class="keyword">return</span> {
          type: <span class="string">'TableKey'</span>
        , key: key
        , value: value
      };
    }
    , tableKeyString: <span class="keyword">function</span>(key, value) {
      <span class="keyword">return</span> {
          type: <span class="string">'TableKeyString'</span>
        , key: key
        , value: value
      };
    }
    , tableValue: <span class="keyword">function</span>(value) {
      <span class="keyword">return</span> {
          type: <span class="string">'TableValue'</span>
        , value: value
      };
    }

    , binaryExpression: <span class="keyword">function</span>(operator, left, right) {
      <span class="keyword">var</span> type = (operator === <span class="string">'and'</span> || operator === <span class="string">'or'</span>) ?
        <span class="string">'LogicalExpression'</span> :
        <span class="string">'BinaryExpression'</span>;

      <span class="keyword">return</span> {
          type: type
        , operator: operator
        , left: left
        , right: right
      };
    }
    , unaryExpression: <span class="keyword">function</span>(operator, argument) {
      <span class="keyword">return</span> {
          type: <span class="string">'UnaryExpression'</span>
        , operator: operator
        , argument: argument
      };
    }
    , memberExpression: <span class="keyword">function</span>(base, indexer, identifier) {
      <span class="keyword">return</span> {
          type: <span class="string">'MemberExpression'</span>
        , indexer: indexer
        , identifier: identifier
        , base: base
      };
    }

    , indexExpression: <span class="keyword">function</span>(base, index) {
      <span class="keyword">return</span> {
          type: <span class="string">'IndexExpression'</span>
        , base: base
        , index: index
      };
    }

    , callExpression: <span class="keyword">function</span>(base, args) {
      <span class="keyword">return</span> {
          type: <span class="string">'CallExpression'</span>
        , base: base
        , <span class="string">'arguments'</span>: args
      };
    }

    , tableCallExpression: <span class="keyword">function</span>(base, argument) {
      <span class="keyword">return</span> {
          type: <span class="string">'TableCallExpression'</span>
        , base: base
        , argument: argument
      };
    }

    , stringCallExpression: <span class="keyword">function</span>(base, argument) {
      <span class="keyword">return</span> {
          type: <span class="string">'StringCallExpression'</span>
        , base: base
        , argument: argument
      };
    }
  };

</pre></div>             </td>           </tr>                               <tr id="section-9">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-9">&#182;</a>               </div>               <h2>Helpers</h2>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="keyword">var</span> slice = Array.prototype.slice
    , toString = Object.prototype.toString;

</pre></div>             </td>           </tr>                               <tr id="section-10">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-10">&#182;</a>               </div>               <p>A sprintf implementation using %index (beginning at 1) to input
arguments in the format string.</p>

<p>Example:</p>

<pre><code>// Unexpected function in token
sprintf('Unexpected %2 in %1.', 'token', 'function');
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">sprintf</span><span class="params">(format)</span> {</span>
    <span class="keyword">var</span> args = slice.call(arguments, <span class="number">1</span>);
    format = format.replace(<span class="regexp">/%(\d)/g</span>, <span class="function"><span class="keyword">function</span> <span class="params">(match, index)</span> {</span>
      match = <span class="string">''</span>; <span class="comment">// jshint</span>
      <span class="keyword">return</span> <span class="string">''</span> + args[index - <span class="number">1</span>] || <span class="string">''</span>;
    });
    <span class="keyword">return</span> format;
  }

</pre></div>             </td>           </tr>                               <tr id="section-11">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-11">&#182;</a>               </div>               <p>Returns a new object with the properties from all objectes passed as
arguments. Last argument takes precedence.</p>

<p>Example:</p>

<pre><code>this.options = extend(options, { output: false });
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> args = slice.call(arguments)
      , dest = {}
      , src, prop;

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = args.length; i &lt; l; i++) {
      src = args[i];
      <span class="keyword">for</span> (prop <span class="keyword">in</span> src) <span class="keyword">if</span> (src.hasOwnProperty(prop)) {
        dest[prop] = src[prop];
      }
    }
    <span class="keyword">return</span> dest;
  }

</pre></div>             </td>           </tr>                               <tr id="section-12">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-12">&#182;</a>               </div>               <h3>Error functions</h3>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-13">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-13">&#182;</a>               </div>               <h4>Raise an exception.</h4>

<p>Raise an exception by passing a token as well as the format message
and parameters as arguments.</p>

<p>If the token doesn't contain location information we use the lexers
current position. This way we can reuse this function both in the lexer
where tokens doesnt exist, and in the parser, where they do.</p>

<p>Example:</p>

<pre><code>// [1:0] expected [ near (
raise(token, "expected %1 near %2", '[', token.value);
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">raise</span><span class="params">(token)</span> {</span>
    <span class="keyword">var</span> message = sprintf.apply(<span class="literal">null</span>, slice.call(arguments, <span class="number">1</span>))
      , error, col;

    <span class="keyword">if</span> (<span class="keyword">typeof</span> token.line !== <span class="string">'undefined'</span>) {
      col = token.range[<span class="number">0</span>] - token.lineStart;
      error = <span class="keyword">new</span> SyntaxError(sprintf(<span class="string">'[%1:%2] %3'</span>, token.line, col, message));
      error.line = token.line;
      error.index = token.range[<span class="number">0</span>];
      error.column = col;
    } <span class="keyword">else</span> {
      col = index - lineStart + <span class="number">1</span>;
      error = <span class="keyword">new</span> SyntaxError(sprintf(<span class="string">'[%1:%2] %3'</span>, line, col, message));
      error.index = index;
      error.line = line;
      error.column = col;
    }
    <span class="keyword">throw</span> error;
  }

</pre></div>             </td>           </tr>                               <tr id="section-14">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-14">&#182;</a>               </div>               <h4>Raise an unexpected token error.</h4>

<p>Example:</p>

<pre><code>// expected &lt;name&gt; near '0'
raiseUnexpectedToken('&lt;name&gt;', token);
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">raiseUnexpectedToken</span><span class="params">(type, token)</span> {</span>
    raise(token, errors.expectedToken, type, token.value);
  }

</pre></div>             </td>           </tr>                               <tr id="section-15">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-15">&#182;</a>               </div>               <h4>Raise a general unexpected error</h4>

<p>Usage should pass either a token object or a symbol string which was
expected. We can also pass a near token to manually specify eg. <eof>.
Otherwise the currently active token will be used.</p>

<p>Example:</p>

<pre><code>// Unexpected symbol 'end' near '&lt;eof&gt;'
unexpected(token);
</code></pre>

<p>If there's no token in the buffer it means we reached <eof>.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">unexpected</span><span class="params">(tokenFound, near)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> near === <span class="string">'undefined'</span>) near = lookahead.value;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> tokenFound.type !== <span class="string">'undefined'</span>) {
      <span class="keyword">var</span> type = TokenName[tokenFound.type];
      <span class="keyword">return</span> raise(tokenFound, errors.unexpected, type, tokenFound.value, near);
    }
    <span class="keyword">return</span> raise(tokenFound, errors.unexpectedSymbol, tokenFound, near);
  }

</pre></div>             </td>           </tr>                               <tr id="section-16">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-16">&#182;</a>               </div>               <h2>Lexer</h2>

<p>The lexer, or the tokenizer reads the input string character by character
and derives a token based on how the set of character begins.</p>

<p>If <code>options.comments</code> is enabled, all comments encountered will be stored
in an array which later will be appended to the chunk object. If disabled,
they will simply be disregarded.</p>

<p>When the lexer has derived a valid token, it will be returned as an object
containing its value and as well as its position in the input (this is
always enabled to provide proper debug messages).</p>

<p>The location information returned will contain the line number where the
token was first encountered (multiline strings), the index position where
that line began, as well as a range array containing the start and end
index of the token.</p>

<p><code>readToken()</code> starts lexing and returns the following token in the stream.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="keyword">var</span> index
    , token
    , lookahead
    , comments
    , tokenStart
    , line
    , lineStart;

  <span class="function"><span class="keyword">function</span> <span class="title">readToken</span><span class="params">()</span> {</span>
    skipWhiteSpace();
    <span class="keyword">if</span> (input[index] === <span class="string">'-'</span> &amp;&amp; input[index + <span class="number">1</span>] === <span class="string">'-'</span>) {
      scanComment();
      skipWhiteSpace();
    }
    <span class="keyword">if</span> (index &gt;= length) <span class="keyword">return</span> {
        type : Tokens.EOF
      , value: TokenName[Tokens.EOF]
      , line: line
      , lineStart: lineStart
      , range: [index, index]
    };

    <span class="keyword">var</span> char = input[index]
      , next = input[index + <span class="number">1</span>]; <span class="comment">// @TODO what if EOF?</span>

</pre></div>             </td>           </tr>                               <tr id="section-17">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-17">&#182;</a>               </div>               <p>Memorize the range index where the token begins.</p>             </td>             <td class="code">               <div class="highlight"><pre>    tokenStart = index;
    <span class="keyword">if</span> (isIdentifierStart(char)) <span class="keyword">return</span> scanIdentifierOrKeyword();

    <span class="keyword">switch</span> (char) {
      <span class="keyword">case</span> <span class="string">'\''</span>: <span class="keyword">case</span> <span class="string">'"'</span>:
        <span class="keyword">return</span> scanStringLiteral();

      <span class="keyword">case</span> <span class="string">'['</span>:
</pre></div>             </td>           </tr>                               <tr id="section-18">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-18">&#182;</a>               </div>               <p>Check for a multiline string.</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="keyword">if</span> (next === <span class="string">'['</span> || next === <span class="string">'='</span>) <span class="keyword">return</span> scanStringLiteral(<span class="literal">true</span>);
        <span class="keyword">return</span> scanPunctuator(char);

      <span class="keyword">case</span> <span class="string">'0'</span>: <span class="keyword">case</span> <span class="string">'1'</span>: <span class="keyword">case</span> <span class="string">'1'</span>: <span class="keyword">case</span> <span class="string">'2'</span>: <span class="keyword">case</span> <span class="string">'3'</span>: <span class="keyword">case</span> <span class="string">'4'</span>: <span class="keyword">case</span> <span class="string">'5'</span>:
      <span class="keyword">case</span> <span class="string">'6'</span>: <span class="keyword">case</span> <span class="string">'7'</span>: <span class="keyword">case</span> <span class="string">'8'</span>: <span class="keyword">case</span> <span class="string">'9'</span>:
        <span class="keyword">return</span> scanNumericLiteral();

      <span class="keyword">case</span> <span class="string">'.'</span>:
</pre></div>             </td>           </tr>                               <tr id="section-19">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-19">&#182;</a>               </div>               <p>If the dot is followed by a digit it's a float.</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="keyword">if</span> (isDecDigit(next)) <span class="keyword">return</span> scanNumericLiteral();
        <span class="keyword">if</span> (next === <span class="string">'.'</span>) {
          <span class="keyword">if</span> (input[index + <span class="number">2</span>] === <span class="string">'.'</span>) <span class="keyword">return</span> scanPunctuator(<span class="string">'...'</span>);
          <span class="keyword">return</span> scanPunctuator(<span class="string">'..'</span>);
        }
        <span class="keyword">return</span> scanPunctuator(char);

      <span class="keyword">case</span> <span class="string">'&gt;'</span>:
        <span class="keyword">if</span> (next === <span class="string">'='</span>) <span class="keyword">return</span> scanPunctuator(<span class="string">'&gt;='</span>);
        <span class="keyword">return</span> scanPunctuator(char);

      <span class="keyword">case</span> <span class="string">'='</span>:
        <span class="keyword">if</span> (next === <span class="string">'='</span>) <span class="keyword">return</span> scanPunctuator(<span class="string">'=='</span>);
        <span class="keyword">return</span> scanPunctuator(char);

      <span class="keyword">case</span> <span class="string">'&lt;'</span>:
        <span class="keyword">if</span> (next === <span class="string">'='</span>) <span class="keyword">return</span> scanPunctuator(<span class="string">'&lt;='</span>);
        <span class="keyword">return</span> scanPunctuator(char);

      <span class="keyword">case</span> <span class="string">'~'</span>:
        <span class="keyword">if</span> (next === <span class="string">'='</span>) <span class="keyword">return</span> scanPunctuator(<span class="string">'~='</span>);
        <span class="keyword">return</span> raise({}, errors.expected, <span class="string">'='</span>, <span class="string">'~'</span>);

      <span class="keyword">case</span> <span class="string">':'</span>:
        <span class="keyword">if</span> (next === <span class="string">':'</span>) <span class="keyword">return</span> scanPunctuator(<span class="string">'::'</span>);
        <span class="keyword">return</span> scanPunctuator(char);

      <span class="keyword">case</span> <span class="string">'*'</span>: <span class="keyword">case</span> <span class="string">'/'</span>: <span class="keyword">case</span> <span class="string">'^'</span>: <span class="keyword">case</span> <span class="string">'%'</span>: <span class="keyword">case</span> <span class="string">','</span>: <span class="keyword">case</span> <span class="string">'{'</span>: <span class="keyword">case</span> <span class="string">'}'</span>:
      <span class="keyword">case</span> <span class="string">'['</span>: <span class="keyword">case</span> <span class="string">']'</span>: <span class="keyword">case</span> <span class="string">'('</span>: <span class="keyword">case</span> <span class="string">')'</span>: <span class="keyword">case</span> <span class="string">';'</span>: <span class="keyword">case</span> <span class="string">'#'</span>: <span class="keyword">case</span> <span class="string">'-'</span>:
      <span class="keyword">case</span> <span class="string">'+'</span>:
        <span class="keyword">return</span> scanPunctuator(char);
    }

    <span class="keyword">return</span> unexpected(char);
  }

</pre></div>             </td>           </tr>                               <tr id="section-20">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-20">&#182;</a>               </div>               <p>Whitespace has no semantic meaning in lua so simply skip ahead, while
tracking the newlines we encounter. This will have to be tracked in all
token functions where multiline values is allowed.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">skipWhiteSpace</span><span class="params">()</span> {</span>
    <span class="keyword">while</span> (index &lt; length) {
      <span class="keyword">if</span> (isLineTerminator(input[index])) {
        index++;
        line++;
        lineStart = index;
      } <span class="keyword">else</span> <span class="keyword">if</span> (isWhiteSpace(input[index])) {
        index++;
      } <span class="keyword">else</span> {
        <span class="keyword">break</span>;
      }
    }
  }

</pre></div>             </td>           </tr>                               <tr id="section-21">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-21">&#182;</a>               </div>               <p>Identifiers, keywords, booleans and nil all look the same syntax wise. We
simply go through them one by one defaulting to an identifier.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanIdentifierOrKeyword</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> word = input[index++]
      , type;

    <span class="keyword">while</span> (isIdentifierPart(input[index])) {
      word += input[index++];
    }

    type = isKeyword(word) ? Tokens.Keyword
      : word === <span class="string">'true'</span> || word === <span class="string">'false'</span> ? Tokens.BooleanLiteral
      : word === <span class="string">'nil'</span> ? Tokens.NilLiteral
      : Tokens.Identifier;

    <span class="keyword">return</span> {
        type: type
      , value: word
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

</pre></div>             </td>           </tr>                               <tr id="section-22">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-22">&#182;</a>               </div>               <p>Once a punctuator reaches this function it should already have been
validated so we simply return it as is.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanPunctuator</span><span class="params">(value)</span> {</span>
    index += value.length;
    <span class="keyword">return</span> {
        type: Tokens.Punctuator
      , value: value
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

</pre></div>             </td>           </tr>                               <tr id="section-23">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-23">&#182;</a>               </div>               <p>Find the string literal by matching the delimiter marks used.
If we're looking for a multiline string it has to be mentioned
in the functioncall with a boolean parameter.</p>

<p>Characters such as \t \n can be escaped with a backslash. If encountered
the following character in the stream will be read without validation.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanStringLiteral</span><span class="params">(isLong)</span> {</span>
    <span class="keyword">var</span> delimiter = input[index++]
      , string = <span class="string">''</span>
      , char;

    <span class="keyword">if</span> (isLong) {
      string = readLongString();
</pre></div>             </td>           </tr>                               <tr id="section-24">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-24">&#182;</a>               </div>               <p>Fail if it's not a multiline literal.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (string === <span class="literal">false</span>) raise(token, errors.expected, <span class="string">'['</span>, token.value);
    }
    <span class="keyword">else</span> {
      <span class="keyword">while</span> (index &lt; length) {
        char = input[index++];
        <span class="keyword">if</span> (char === delimiter) <span class="keyword">break</span>;
        <span class="keyword">if</span> (char === <span class="string">'\\'</span>) {
          <span class="keyword">var</span> byte;
          <span class="keyword">switch</span> (input[index]) {
</pre></div>             </td>           </tr>                               <tr id="section-25">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-25">&#182;</a>               </div>               <p>Lua allow the following escape sequences.
We don't escape the bell sequence.</p>             </td>             <td class="code">               <div class="highlight"><pre>            <span class="keyword">case</span> <span class="string">'n'</span>: string += <span class="string">'\n'</span>; index++; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'r'</span>: string += <span class="string">'\r'</span>; index++; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'t'</span>: string += <span class="string">'\t'</span>; index++; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'v'</span>: string += <span class="string">'\v'</span>; index++; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'b'</span>: string += <span class="string">'\b'</span>; index++; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'f'</span>: string += <span class="string">'\f'</span>; index++; <span class="keyword">break</span>;
</pre></div>             </td>           </tr>                               <tr id="section-26">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-26">&#182;</a>               </div>               <p>Skips the following span of white-space.</p>             </td>             <td class="code">               <div class="highlight"><pre>            <span class="keyword">case</span> <span class="string">'z'</span>: index++; skipWhiteSpace(); <span class="keyword">break</span>;
</pre></div>             </td>           </tr>                               <tr id="section-27">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-27">&#182;</a>               </div>               <p>Byte representation should for now be returned as is.</p>             </td>             <td class="code">               <div class="highlight"><pre>            <span class="keyword">default</span>:
              string += char;
          }
        }
</pre></div>             </td>           </tr>                               <tr id="section-28">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-28">&#182;</a>               </div>               <p>EOF or <code>\n</code> terminates a string literal. If we haven't found the
ending delimiter by now, raise an exception.</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= length || isLineTerminator(char))
          raise({}, errors.unfinishedString, string + char);
        <span class="keyword">else</span>
          string += char;
      }
    }

    <span class="keyword">return</span> {
        type: Tokens.StringLiteral
      , value: string
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

</pre></div>             </td>           </tr>                               <tr id="section-29">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-29">&#182;</a>               </div>               <p>Numeric literals will be returned as floating-point numbers instead of
strings. The raw value will still be attached to the token in a separate
property.</p>

<p>If a hexadecimal number is encountered, it will simply be converted.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanNumericLiteral</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> char = input[index]
      , next = input[index + <span class="number">1</span>];

    <span class="keyword">if</span> (char === <span class="string">'0'</span> &amp;&amp; ~<span class="string">'xX'</span>.indexOf(next)) <span class="keyword">return</span> scanHexLiteral();
    <span class="keyword">else</span> <span class="keyword">return</span> scanDecLiteral();
  }

</pre></div>             </td>           </tr>                               <tr id="section-30">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-30">&#182;</a>               </div>               <p>Lua hexadecimals have an optional fraction part and an optional binary
exoponent part. These are not included in JavaScript so we will compute all
three parts separately and then sum them up at the end of the function.</p>

<pre><code>Digit := toDec(digit)
Fraction := toDec(fraction) / 16 ^ fractionCount
BinaryExp := 2 ^ binaryExp
Number := ( Digit + Fraction ) * BinaryExp
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanHexLiteral</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> fraction = <span class="number">0</span> <span class="comment">// defaults to 0 as it gets summed</span>
      , binaryExponent = <span class="number">1</span> <span class="comment">// defaults to 1 as it gets multiplied</span>
      , binarySign = <span class="number">1</span> <span class="comment">// positive</span>
      , digit = <span class="string">''</span> <span class="comment">// The main digit is required or this is not a valid hex.</span>
      , raw = <span class="string">'0x'</span>;

    index += <span class="number">2</span>; <span class="comment">// Skip 0x part</span>

</pre></div>             </td>           </tr>                               <tr id="section-31">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-31">&#182;</a>               </div>               <p>A minimum of one hex digit is required.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (!isHexDigit(input[index])) raise({}, errors.malformedNumber, raw);
    <span class="keyword">while</span> (isHexDigit(input[index])) digit += input[index++];

</pre></div>             </td>           </tr>                               <tr id="section-32">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-32">&#182;</a>               </div>               <p>Convert the hexadecimal digit to base 10.</p>             </td>             <td class="code">               <div class="highlight"><pre>    raw += digit;
    digit = parseInt(digit, <span class="number">16</span>);

</pre></div>             </td>           </tr>                               <tr id="section-33">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-33">&#182;</a>               </div>               <p>Fraction part i optional.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (input[index] === <span class="string">'.'</span>) {
      fraction = <span class="string">''</span>;
      raw += input[index++];

      <span class="keyword">while</span> (isHexDigit(input[index])) fraction += input[index++];
      raw += fraction;

</pre></div>             </td>           </tr>                               <tr id="section-34">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-34">&#182;</a>               </div>               <p>Empty fraction parts should default to 0.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (fraction === <span class="string">''</span>) fraction = <span class="number">0</span>;
</pre></div>             </td>           </tr>                               <tr id="section-35">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-35">&#182;</a>               </div>               <p>Convert the fraction part into 0.x so we can use summation.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">else</span> fraction = parseInt(fraction, <span class="number">16</span>) / Math.pow(<span class="number">16</span>, fraction.length);
    }

</pre></div>             </td>           </tr>                               <tr id="section-36">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-36">&#182;</a>               </div>               <p>Binary exponents are optional</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (~<span class="string">'pP'</span>.indexOf(input[index])) {
      binaryExponent = <span class="string">''</span>;
      raw += input[index++];

</pre></div>             </td>           </tr>                               <tr id="section-37">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-37">&#182;</a>               </div>               <p>Sign part is optional and defaults to 1 (positive).</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (~<span class="string">'+-'</span>.indexOf(input[index])) {
        raw += input[index];
        binarySign = input[index++] === <span class="string">'+'</span> ? <span class="number">1</span> : -<span class="number">1</span>;
      }
</pre></div>             </td>           </tr>                               <tr id="section-38">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-38">&#182;</a>               </div>               <p>The binary exponent sign requires a decimal digit.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (!isDecDigit(input[index])) raise({}, errors.malformedNumber, raw);
      <span class="keyword">while</span> (isDecDigit(input[index])) binaryExponent += input[index++];

</pre></div>             </td>           </tr>                               <tr id="section-39">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-39">&#182;</a>               </div>               <p>Calculate the binary exponent of the number.</p>             </td>             <td class="code">               <div class="highlight"><pre>      raw += binaryExponent;
      binaryExponent = Math.pow(<span class="number">2</span>, binaryExponent * binarySign);
    }

    <span class="keyword">return</span> {
        type: Tokens.NumericLiteral
      , value: (digit + fraction) * binaryExponent
      , raw: raw
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

</pre></div>             </td>           </tr>                               <tr id="section-40">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-40">&#182;</a>               </div>               <p>Decimal numbers are exactly the same in Lua and in JavaScript, but to
provide proper error messages and just for the heck of it, we parse them
manually instead of using native functions.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanDecLiteral</span><span class="params">()</span> {</span>
</pre></div>             </td>           </tr>                               <tr id="section-41">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-41">&#182;</a>               </div>               <p>We don't read in the first char as the number might be a floating point.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">var</span> number = <span class="string">''</span>;

    <span class="keyword">while</span> (isDecDigit(input[index])) number += input[index++];
</pre></div>             </td>           </tr>                               <tr id="section-42">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-42">&#182;</a>               </div>               <p>Fraction part is optional</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (input[index] === <span class="string">'.'</span>) {
      number += input[index++];
</pre></div>             </td>           </tr>                               <tr id="section-43">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-43">&#182;</a>               </div>               <p>Fraction part defaults to 0 in Lua.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">while</span> (isDecDigit(input[index])) number += input[index++];
    }
</pre></div>             </td>           </tr>                               <tr id="section-44">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-44">&#182;</a>               </div>               <p>Exponent part is optional.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (~<span class="string">'eE'</span>.indexOf(input[index])) {
      number += input[index++]; <span class="comment">// append e</span>
</pre></div>             </td>           </tr>                               <tr id="section-45">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-45">&#182;</a>               </div>               <p>Sign part is optional.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (~<span class="string">'+-'</span>.indexOf(input[index])) number += input[index++];
</pre></div>             </td>           </tr>                               <tr id="section-46">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-46">&#182;</a>               </div>               <p>An exponent is required to contain at least one decimal digit.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (!isDecDigit(input[index])) raise({}, errors.malformedNumber, number);
      <span class="keyword">while</span> (isDecDigit(input[index])) number += input[index++];
    }

    <span class="keyword">return</span> {
        type: Tokens.NumericLiteral
      , value: parseFloat(number)
      , raw: number
      , line: line
      , lineStart: lineStart
      , range: [tokenStart, index]
    };
  }

</pre></div>             </td>           </tr>                               <tr id="section-47">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-47">&#182;</a>               </div>               <p>Comments begin with -- after which it will be decided if they are multiline
comments or not.</p>

<p>The multiline functionality works the exact same way as with string
literals so we reuse the functionality.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">scanComment</span><span class="params">()</span> {</span>
    tokenStart = index;
    index += <span class="number">2</span>; <span class="comment">// --</span>
    <span class="keyword">var</span> char = input[index]
      , content = <span class="string">''</span>
      , isLong = <span class="literal">false</span>;

    <span class="keyword">if</span> (char === <span class="string">'['</span>) {
      index++;
      content = readLongString();
</pre></div>             </td>           </tr>                               <tr id="section-48">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-48">&#182;</a>               </div>               <p>This wasn't a multiline comment after all.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (content === <span class="literal">false</span>) content = char;
      <span class="keyword">else</span> {
        isLong = <span class="literal">true</span>;
        index += <span class="number">2</span>; <span class="comment">// --</span>
      }
    }
</pre></div>             </td>           </tr>                               <tr id="section-49">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-49">&#182;</a>               </div>               <p>Scan until next line as long as it's not a multiline comment.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">while</span> (!isLong &amp;&amp; index &lt; length) {
      <span class="keyword">if</span> (isLineTerminator(char = input[index])) <span class="keyword">break</span>;
      index++;
      content += char;
    }

    <span class="keyword">if</span> (options.comments) {
      comments.push({
          type: <span class="string">'Comment'</span>
        , value: content
</pre></div>             </td>           </tr>                               <tr id="section-50">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-50">&#182;</a>               </div>               <p>, line: line
, lineStart: lineStart
, range: [tokenStart, index]</p>             </td>             <td class="code">               <div class="highlight"><pre>      });
    }
  }

</pre></div>             </td>           </tr>                               <tr id="section-51">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-51">&#182;</a>               </div>               <p>Read a multiline string by calculating the depth of <code>=</code> characters and
then appending until an equal depth is found.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">readLongString</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> level = <span class="number">0</span>
      , content = <span class="string">''</span>
      , char
      , commentTerminator = <span class="literal">false</span>;

</pre></div>             </td>           </tr>                               <tr id="section-52">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-52">&#182;</a>               </div>               <p>Calculate the depth of the comment.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">while</span> (input[index + level] === <span class="string">'='</span>) level++;
</pre></div>             </td>           </tr>                               <tr id="section-53">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-53">&#182;</a>               </div>               <p>Exit, this is not a long string afterall.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (input[index + level] !== <span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>;

    index += level + <span class="number">1</span>;
    char = input[index];

</pre></div>             </td>           </tr>                               <tr id="section-54">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-54">&#182;</a>               </div>               <p>If the first character is a newline, ignore it and begin on next line.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (isLineTerminator(char)) {
      char = input[++index];
      line++;
      lineStart = index;
    }

    <span class="keyword">while</span> (index &lt; length) {
      char = input[index++];

</pre></div>             </td>           </tr>                               <tr id="section-55">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-55">&#182;</a>               </div>               <p>We have to keep track of newlines as <code>skipWhiteSpace()</code> does not get to
scan this part.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (isLineTerminator(char)) {
        line++;
        lineStart = index;
      }

</pre></div>             </td>           </tr>                               <tr id="section-56">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-56">&#182;</a>               </div>               <p>Once the delimiter is found, iterate through the depth count and see if
it matches.</p>             </td>             <td class="code">               <div class="highlight"><pre>
      <span class="keyword">if</span> (char === <span class="string">']'</span>) {
        commentTerminator = <span class="literal">true</span>;
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; level; i++) {
          <span class="keyword">if</span> (input[index + i] !== <span class="string">'='</span>) commentTerminator = <span class="literal">false</span>;
        }
        <span class="keyword">if</span> (input[index + level] !== <span class="string">']'</span>) commentTerminator = <span class="literal">false</span>;
      }

</pre></div>             </td>           </tr>                               <tr id="section-57">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-57">&#182;</a>               </div>               <p>We reached the end of the multiline string. Get out now.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (commentTerminator) <span class="keyword">break</span>;
      content += char;
    }
    index += level + <span class="number">1</span>;

    <span class="keyword">return</span> content;
  }

</pre></div>             </td>           </tr>                               <tr id="section-58">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-58">&#182;</a>               </div>               <h2>Lex functions and helpers.</h2>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-59">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-59">&#182;</a>               </div>               <p>Read the next token.</p>

<p>This is actually done by setting the current token to the lookahead and
reading in a new lookahead token.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span> {</span>
    token = lookahead;
    peek();
  }

</pre></div>             </td>           </tr>                               <tr id="section-60">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-60">&#182;</a>               </div>               <p>Peak ahead and store the next token in the <code>lookahead</code> variable.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">peek</span><span class="params">()</span> {</span>
    lookahead = readToken();
  }

</pre></div>             </td>           </tr>                               <tr id="section-61">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-61">&#182;</a>               </div>               <p>Consume a token if its value matches. Once consumed or not, return the
success of the operation.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">consume</span><span class="params">(value)</span> {</span>
    <span class="keyword">if</span> (token.value === value) {
      next();
      <span class="keyword">return</span> <span class="literal">true</span>;
    }
    <span class="keyword">return</span> <span class="literal">false</span>;
  }

</pre></div>             </td>           </tr>                               <tr id="section-62">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-62">&#182;</a>               </div>               <p>Expect the next token value to match. If not, throw an exception.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">expect</span><span class="params">(value)</span> {</span>
    <span class="keyword">if</span> (token.value === value) next();
    <span class="keyword">else</span> raise(token, errors.expected, value, token.value);
  }

</pre></div>             </td>           </tr>                               <tr id="section-63">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-63">&#182;</a>               </div>               <h3>Validation functions</h3>

<p>These will be rethought.</p>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-64">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-64">&#182;</a>               </div>               <p>@TODO add "Any other Unicode space separator"</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">isWhiteSpace</span><span class="params">(char)</span> {</span>
    <span class="keyword">return</span> regexp.whiteSpace.test(char);
  }

</pre></div>             </td>           </tr>                               <tr id="section-65">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-65">&#182;</a>               </div>               <p>@TODO does lua conform with the unicode standard?
@see http://en.wikipedia.org/wiki/Newline#Unicode</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">isLineTerminator</span><span class="params">(char)</span> {</span>
    <span class="keyword">return</span> regexp.lineTerminator.test(char);
  }

  <span class="function"><span class="keyword">function</span> <span class="title">isDecDigit</span><span class="params">(char)</span> {</span>
    <span class="keyword">return</span> regexp.decDigit.test(char);
  }

  <span class="function"><span class="keyword">function</span> <span class="title">isHexDigit</span><span class="params">(char)</span> {</span>
    <span class="keyword">return</span> regexp.hexDigit.test(char);
  }

</pre></div>             </td>           </tr>                               <tr id="section-66">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-66">&#182;</a>               </div>               <p>Lua identifiers cannot use locale-dependent letters.
http://www.lua.org/manual/5.2/manual.html#8.1</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">isIdentifierStart</span><span class="params">(char)</span> {</span>
    <span class="keyword">return</span> regexp.identifierStart.test(char);
  }

  <span class="function"><span class="keyword">function</span> <span class="title">isIdentifierPart</span><span class="params">(char)</span> {</span>
    <span class="keyword">return</span> regexp.identifierPart.test(char);
  }

</pre></div>             </td>           </tr>                               <tr id="section-67">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-67">&#182;</a>               </div>               <p>@see http://www.lua.org/manual/5.2/manual.html#3.1
Nil, true, false</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">isKeyword</span><span class="params">(id)</span> {</span>
    <span class="keyword">var</span> keyword = <span class="literal">false</span>;

    <span class="keyword">switch</span> (id.length) {
      <span class="keyword">case</span> <span class="number">2</span>:
        keyword = (id === <span class="string">'do'</span> || id === <span class="string">'if'</span> || id === <span class="string">'in'</span> || id === <span class="string">'or'</span>);
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="number">3</span>:
        keyword = (id === <span class="string">'and'</span> || id === <span class="string">'end'</span> || id === <span class="string">'for'</span> || id === <span class="string">'not'</span>);
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="number">4</span>:
        keyword = (id === <span class="string">'else'</span> || id === <span class="string">'goto'</span> || id === <span class="string">'then'</span>);
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="number">5</span>:
        keyword = (id === <span class="string">'break'</span> || id === <span class="string">'local'</span> || id === <span class="string">'until'</span> || id === <span class="string">'while'</span>);
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="number">6</span>:
        keyword = (id === <span class="string">'elseif'</span> || id === <span class="string">'repeat'</span> || id === <span class="string">'return'</span>);
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="number">8</span>:
        keyword = (id === <span class="string">'function'</span>);
        <span class="keyword">break</span>;
    }
</pre></div>             </td>           </tr>                               <tr id="section-68">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-68">&#182;</a>               </div>               <p>We make room here for reserved words, modifications etc.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">return</span> keyword;
  }

</pre></div>             </td>           </tr>                               <tr id="section-69">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-69">&#182;</a>               </div>               <p>@TODO this needs to be rethought.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">isCallExpression</span><span class="params">(expression)</span> {</span>
    <span class="keyword">switch</span> (expression.type) {
      <span class="keyword">case</span> <span class="string">'CallExpression'</span>:
      <span class="keyword">case</span> <span class="string">'TableCallExpression'</span>:
      <span class="keyword">case</span> <span class="string">'StringCallExpression'</span>:
        <span class="keyword">return</span> <span class="literal">true</span>;
    }
    <span class="keyword">return</span> <span class="literal">false</span>;
  }

</pre></div>             </td>           </tr>                               <tr id="section-70">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-70">&#182;</a>               </div>               <p>Check if the token syntactically closes a block.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">isBlockFollow</span><span class="params">(token)</span> {</span>
    <span class="keyword">if</span> (token.type === Tokens.EOF) <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span> (token.type !== Tokens.Keyword) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">switch</span> (token.value) {
      <span class="keyword">case</span> <span class="string">'else'</span>: <span class="keyword">case</span> <span class="string">'elseif'</span>:
      <span class="keyword">case</span> <span class="string">'end'</span>: <span class="keyword">case</span> <span class="string">'until'</span>:
        <span class="keyword">return</span> <span class="literal">true</span>;
      <span class="keyword">default</span>:
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
  }

</pre></div>             </td>           </tr>                               <tr id="section-71">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-71">&#182;</a>               </div>               <h2>Parse functions</h2>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-72">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-72">&#182;</a>               </div>               <p>Chunk is the main program object. Syntactically it's the same as a block.</p>

<pre><code>chunk ::= block
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseChunk</span><span class="params">()</span> {</span>
    peek();
    next();
    <span class="keyword">var</span> body = parseBlock();
    <span class="keyword">if</span> (token.type !== Tokens.EOF) unexpected(token);
    <span class="keyword">return</span> ast.chunk(body);
  }

</pre></div>             </td>           </tr>                               <tr id="section-73">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-73">&#182;</a>               </div>               <p>A block contains a list of statements with an optional return statement
as its last statement.</p>

<pre><code>block ::= {stat} [retstat]
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseBlock</span><span class="params">(terminator)</span> {</span>
    <span class="keyword">var</span> block = []
      , statement;

    <span class="keyword">while</span> (!isBlockFollow(token)) {
</pre></div>             </td>           </tr>                               <tr id="section-74">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-74">&#182;</a>               </div>               <p>Return has to be the last statement in a block.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (token.value === <span class="string">'return'</span>) {
        block.push(parseStatement());
        <span class="keyword">break</span>;
      }
      statement = parseStatement();
</pre></div>             </td>           </tr>                               <tr id="section-75">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-75">&#182;</a>               </div>               <p>Statements are only added if they are returned, this allows us to
ignore some statements, such as EmptyStatement.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (statement) block.push(statement);
    }
</pre></div>             </td>           </tr>                               <tr id="section-76">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-76">&#182;</a>               </div>               <p>Doesn't really need an ast node</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">return</span> block;
  }
</pre></div>             </td>           </tr>                               <tr id="section-77">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-77">&#182;</a>               </div>               <p>There are two types of statements, simple and compound.
Statements are executed solely for their side effects.</p>

<pre><code>statement ::= break | goto | do | while | repeat | return
     | if | for | function | local | label | assignment
     | functioncall | ';'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseStatement</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (token.type === Tokens.Keyword) {
      <span class="keyword">switch</span> (token.value) { <span class="comment">// @TODO make next() inlinable</span>
        <span class="keyword">case</span> <span class="string">'break'</span>:    next(); <span class="keyword">return</span> parseBreakStatement();
        <span class="keyword">case</span> <span class="string">'goto'</span>:     next(); <span class="keyword">return</span> parseGotoStatement();
        <span class="keyword">case</span> <span class="string">'do'</span>:       next(); <span class="keyword">return</span> parseDoStatement();
        <span class="keyword">case</span> <span class="string">'while'</span>:    next(); <span class="keyword">return</span> parseWhileStatement();
        <span class="keyword">case</span> <span class="string">'repeat'</span>:   next(); <span class="keyword">return</span> parseRepeatStatement();
        <span class="keyword">case</span> <span class="string">'return'</span>:   next(); <span class="keyword">return</span> parseReturnStatement();
        <span class="keyword">case</span> <span class="string">'if'</span>:       next(); <span class="keyword">return</span> parseIfStatement();
        <span class="keyword">case</span> <span class="string">'for'</span>:      next(); <span class="keyword">return</span> parseForStatement();
        <span class="keyword">case</span> <span class="string">'function'</span>:
          next();
          <span class="keyword">var</span> name = parseFunctionName();
          <span class="keyword">return</span> parseFunctionDeclaration(name);
        <span class="keyword">case</span> <span class="string">'local'</span>:    next(); <span class="keyword">return</span> parseLocalStatement(); <span class="comment">// @TODO</span>
      }
    }

    <span class="keyword">if</span> (token.type === Tokens.Punctuator) {
      <span class="keyword">if</span> (consume(<span class="string">'::'</span>)) <span class="keyword">return</span> parseLabelStatement();
    }

</pre></div>             </td>           </tr>                               <tr id="section-78">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-78">&#182;</a>               </div>               <p>Keep a reference to the previous token for better error messages in case
of invalid statement
@TODO this could use some clean up.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">var</span> previous = token;
    <span class="keyword">var</span> expression = parsePrefixExpression();

    <span class="keyword">if</span> (expression) {
      <span class="keyword">var</span> exp;
</pre></div>             </td>           </tr>                               <tr id="section-79">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-79">&#182;</a>               </div>               <p>AssignmentStatement</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (~<span class="string">',='</span>.indexOf(token.value)) {
        <span class="keyword">var</span> variables = [expression];
        <span class="keyword">var</span> init = [];
</pre></div>             </td>           </tr>                               <tr id="section-80">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-80">&#182;</a>               </div>               <p>@TODO need to check grammar properly for this
we should only allow Name | Indexed | Member</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="keyword">while</span> (consume(<span class="string">','</span>)) {
          exp = parsePrefixExpression();
          <span class="keyword">if</span> (exp == <span class="literal">null</span>) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token);
          variables.push(exp);
        }
        expect(<span class="string">'='</span>);
        <span class="keyword">do</span> {
          exp = parseExpression();
          <span class="keyword">if</span> (exp == <span class="literal">null</span>) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token);
          init.push(exp);
        } <span class="keyword">while</span> (consume(<span class="string">','</span>));
        <span class="keyword">return</span> ast.assignmentStatement(variables, init);
      }

</pre></div>             </td>           </tr>                               <tr id="section-81">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-81">&#182;</a>               </div>               <p>CallStatement</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (isCallExpression(expression)) { <span class="comment">// @TODO ast change can break this.</span>
        <span class="keyword">return</span> ast.callStatement(expression);
      }

</pre></div>             </td>           </tr>                               <tr id="section-82">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-82">&#182;</a>               </div>               <p>The prefix expression was neither part of an assignment or a
callstatement, however as it was valid it's been consumed, so raise the
exception on the previous token to provide a helpful message.</p>             </td>             <td class="code">               <div class="highlight"><pre>      unexpected(previous);
    }

</pre></div>             </td>           </tr>                               <tr id="section-83">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-83">&#182;</a>               </div>               <p>What's lua practice regarding semicolon? If it's used more often we
should place it at the top of the function as Lua core does it.</p>

<p>When a <code>;</code> is encounted, simply eat it and return nothing.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (consume(<span class="string">';'</span>)) <span class="keyword">return</span>;

    unexpected(token);
  }


</pre></div>             </td>           </tr>                               <tr id="section-84">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-84">&#182;</a>               </div>               <h2>Statements</h2>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-85">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-85">&#182;</a>               </div>               <pre><code>label ::= '::' Name '::'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseLabelStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> label = parseIdentifier();
    expect(<span class="string">'::'</span>);
    <span class="keyword">return</span> ast.labelStatement(label);
  }

</pre></div>             </td>           </tr>                               <tr id="section-86">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-86">&#182;</a>               </div>               <pre><code>break ::= 'break'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseBreakStatement</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> ast.breakStatement();
  }

</pre></div>             </td>           </tr>                               <tr id="section-87">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-87">&#182;</a>               </div>               <pre><code>goto ::= 'goto' Name
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseGotoStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> label = parseIdentifier();
    <span class="keyword">return</span> ast.gotoStatement(label);
  }

</pre></div>             </td>           </tr>                               <tr id="section-88">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-88">&#182;</a>               </div>               <pre><code>do ::= 'do' block 'end'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseDoStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> body = parseBlock();
    expect(<span class="string">'end'</span>);
    <span class="keyword">return</span> ast.doStatement(body);
  }

</pre></div>             </td>           </tr>                               <tr id="section-89">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-89">&#182;</a>               </div>               <pre><code>while ::= 'while' exp 'do' block 'end'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseWhileStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> condition = parseExpression();
    expect(<span class="string">'do'</span>);
    <span class="keyword">var</span> body = parseBlock();
    expect(<span class="string">'end'</span>);
    <span class="keyword">return</span> ast.whileStatement(condition, body);
  }

</pre></div>             </td>           </tr>                               <tr id="section-90">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-90">&#182;</a>               </div>               <pre><code>repeat ::= 'repeat' block 'until' exp
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseRepeatStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> body = parseBlock();
    expect(<span class="string">'until'</span>);
    <span class="keyword">var</span> condition = parseExpression();
    <span class="keyword">if</span> (condition == <span class="literal">null</span>) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token);
    <span class="keyword">return</span> ast.repeatStatement(condition, body);
  }

</pre></div>             </td>           </tr>                               <tr id="section-91">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-91">&#182;</a>               </div>               <pre><code>retstat ::= 'return' [exp {',' exp}] [';']
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseReturnStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> expressions = [];
</pre></div>             </td>           </tr>                               <tr id="section-92">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-92">&#182;</a>               </div>               <p>@TODO what happens if return is somewhere in the middle of a block as
lua \n dont have semantic meaning? Lua C compiler ends return
statements if they are followed by else|elseif|end|eos.
@see block_follow</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (token.value !== <span class="string">'end'</span>) {
      <span class="keyword">var</span> expression = parseExpression();
      <span class="keyword">if</span> (expression) expressions.push(expression);
      <span class="keyword">while</span> (consume(<span class="string">','</span>)) {
        expression = parseExpression();
</pre></div>             </td>           </tr>                               <tr id="section-93">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-93">&#182;</a>               </div>               <p>@TODO this should be abstracted for all lists</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="keyword">if</span> (expression == <span class="literal">null</span>) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token);
        expressions.push(expression);
      }
      consume(<span class="string">';'</span>); <span class="comment">// grammar tells us ; is optional here.</span>
    }
    <span class="keyword">return</span> ast.returnStatement(expressions);
  }

</pre></div>             </td>           </tr>                               <tr id="section-94">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-94">&#182;</a>               </div>               <pre><code>if ::= 'if' exp 'then' block {elif} ['else' block] 'end'
elif ::= 'elseif' exp 'then' block
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseIfStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> clauses = []
      , condition
      , body;

    <span class="keyword">do</span> {
      condition = parseExpression();
      expect(<span class="string">'then'</span>);
      body = parseBlock();
      clauses.push(ast.clause(condition, body));
    } <span class="keyword">while</span> (consume(<span class="string">'elseif'</span>));

    <span class="keyword">if</span> (consume(<span class="string">'else'</span>)) {
      body = parseBlock();
      clauses.push(ast.clause(<span class="literal">null</span>, body));
    }

    expect(<span class="string">'end'</span>);
    <span class="keyword">return</span> ast.ifStatement(clauses);
  }

</pre></div>             </td>           </tr>                               <tr id="section-95">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-95">&#182;</a>               </div>               <p>There are two types of for statements, generic and numeric.</p>

<pre><code>for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'
for ::= namelist 'in' explist 'do' block 'end'
namelist ::= Name {',' Name}
explist ::= exp {',' exp}
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseForStatement</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> variable = parseIdentifier()
      , body;

    <span class="keyword">if</span> (consume(<span class="string">'='</span>)) {
</pre></div>             </td>           </tr>                               <tr id="section-96">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-96">&#182;</a>               </div>               <p>Start expression</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">var</span> start = parseExpression();
      <span class="keyword">if</span> (start == <span class="literal">null</span>) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token); <span class="comment">// @TODO</span>
      expect(<span class="string">','</span>);
</pre></div>             </td>           </tr>                               <tr id="section-97">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-97">&#182;</a>               </div>               <p>End expression</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">var</span> end = parseExpression();
      <span class="keyword">if</span> (end == <span class="literal">null</span>) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token); <span class="comment">// @TODO</span>
</pre></div>             </td>           </tr>                               <tr id="section-98">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-98">&#182;</a>               </div>               <p>Optional step expression</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">var</span> step = <span class="literal">null</span>;
      <span class="keyword">if</span> (consume(<span class="string">','</span>)) {
        step = parseExpression();
        <span class="keyword">if</span> (step == <span class="literal">null</span>) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token); <span class="comment">// @TODO</span>
      }

      expect(<span class="string">'do'</span>);
      body = parseBlock();
      expect(<span class="string">'end'</span>);

      <span class="keyword">return</span> ast.forNumericStatement(variable, start, end, step, body);

</pre></div>             </td>           </tr>                               <tr id="section-99">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-99">&#182;</a>               </div>               <p>If the first expression is not followed by a <code>=</code> punctuator, this is a
Generic For Statement.</p>             </td>             <td class="code">               <div class="highlight"><pre>    } <span class="keyword">else</span> {
</pre></div>             </td>           </tr>                               <tr id="section-100">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-100">&#182;</a>               </div>               <p>The namelist can contain one or more identifiers.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">var</span> variables = [variable];
      <span class="keyword">while</span> (consume(<span class="string">','</span>)) variables.push(parseIdentifier());
      expect(<span class="string">'in'</span>);
      <span class="keyword">var</span> iterators = [];

</pre></div>             </td>           </tr>                               <tr id="section-101">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-101">&#182;</a>               </div>               <p>One or more expressions in the explist.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">do</span> {
        <span class="keyword">var</span> expression = parseExpression();
        <span class="keyword">if</span> (expression == <span class="literal">null</span>) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token); <span class="comment">// @TODO</span>
        iterators.push(expression);
      } <span class="keyword">while</span> (consume(<span class="string">','</span>));

      expect(<span class="string">'do'</span>);
      body = parseBlock();
      expect(<span class="string">'end'</span>);

      <span class="keyword">return</span> ast.forGenericStatement(variables, iterators, body);
    }
  }

</pre></div>             </td>           </tr>                               <tr id="section-102">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-102">&#182;</a>               </div>               <p>Local statements can either be variable assignments or function
definitions. If a function definition is found, it will be delegated to
<code>parseFunctionDeclaration()</code> with the isLocal boolean.</p>

<p>This AST structure might change into a local assignment with a function
child.</p>

<pre><code>local ::= 'local' 'function' Name funcdecl
   | 'local' Name {',' Name} ['=' exp {',' exp}
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseLocalStatement</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (token.type === Tokens.Identifier) {
      <span class="keyword">var</span> variables = [];
      <span class="keyword">var</span> init = [];

      <span class="keyword">do</span> {
        variables.push(parseIdentifier());
      } <span class="keyword">while</span> (consume(<span class="string">','</span>));

      <span class="keyword">if</span> (consume(<span class="string">'='</span>)) {
        <span class="keyword">do</span> {
          <span class="keyword">var</span> expression = parseExpression();
          <span class="keyword">if</span> (expression == <span class="literal">null</span>) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token);
          init.push(expression);
        } <span class="keyword">while</span> (consume(<span class="string">','</span>));
      }

      <span class="keyword">return</span> ast.localStatement(variables, init);
    }
    <span class="keyword">if</span> (consume(<span class="string">'function'</span>)) {
</pre></div>             </td>           </tr>                               <tr id="section-103">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-103">&#182;</a>               </div>               <p>MemberExpressions are not allowed in local function statements.</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">var</span> name = parseIdentifier();
      <span class="keyword">return</span> parseFunctionDeclaration(name, <span class="literal">true</span>);
    } <span class="keyword">else</span> {
      raiseUnexpectedToken(<span class="string">'&lt;name&gt;'</span>, token);
    }
  }


</pre></div>             </td>           </tr>                               <tr id="section-104">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-104">&#182;</a>               </div>               <h3>Non-statements</h3>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-105">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-105">&#182;</a>               </div>               <pre><code>Identifier ::= Name
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseIdentifier</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> identifier = token.value;
    <span class="keyword">if</span> (token.type !== Tokens.Identifier) raiseUnexpectedToken(<span class="string">'&lt;name&gt;'</span>, token);
    next();
    <span class="keyword">return</span> ast.identifier(identifier);
  }


</pre></div>             </td>           </tr>                               <tr id="section-106">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-106">&#182;</a>               </div>               <p>Parse the functions parameters and body block. The name should already
have been parsed and passed to this declaration function. By separating
this we allow for anonymous functions in expression.</p>

<p>For local functions there's a boolean parameter which needs to be set
when parsing the declaration.</p>

<pre><code>funcdecl ::= '(' [parlist] ')' block 'end'
parlist ::= Name {',' Name} | [',' '...'] | '...'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseFunctionDeclaration</span><span class="params">(name, isLocal)</span> {</span>
    <span class="keyword">var</span> isVararg = <span class="literal">false</span>;
    <span class="keyword">var</span> parameters = [];
    expect(<span class="string">'('</span>);

    <span class="keyword">if</span> (consume(<span class="string">'...'</span>)) isVararg = <span class="literal">true</span>;
    <span class="keyword">else</span> <span class="keyword">if</span> (token.type === Tokens.Identifier) { <span class="comment">// @TODO not only identifiers</span>
      <span class="keyword">do</span> {
        <span class="keyword">if</span> (consume(<span class="string">'...'</span>)) {
          isVararg = <span class="literal">true</span>;
          <span class="keyword">break</span>;
        }
        parameters.push(parseIdentifier());
      } <span class="keyword">while</span> (consume(<span class="string">','</span>));
    }
    <span class="keyword">if</span> (isVararg) expect(<span class="string">')'</span>);
    <span class="keyword">else</span> <span class="keyword">if</span> (!consume(<span class="string">')'</span>)) raiseUnexpectedToken(<span class="string">'&lt;name&gt; or \'...\''</span>, token);

    <span class="keyword">var</span> body = parseBlock();
    expect(<span class="string">'end'</span>);

    <span class="keyword">return</span> ast.functionStatement(name, parameters, isVararg, isLocal || <span class="literal">false</span>, body);
  }

</pre></div>             </td>           </tr>                               <tr id="section-107">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-107">&#182;</a>               </div>               <p>Parse the function name as identifiers and member expressions.</p>

<pre><code>Name {'.' Name} [':' Name]
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseFunctionName</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> base = parseIdentifier();

    <span class="keyword">while</span> (consume(<span class="string">'.'</span>)) {
      base = ast.memberExpression(base, <span class="string">'.'</span>, parseIdentifier());
    }

    <span class="keyword">if</span> (consume(<span class="string">':'</span>)) {
      base = ast.memberExpression(base, <span class="string">':'</span>, parseIdentifier());
    }

    <span class="keyword">return</span> base;
  }

</pre></div>             </td>           </tr>                               <tr id="section-108">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-108">&#182;</a>               </div>               <pre><code>tableconstructor ::= '{' [fieldlist] '}'
fieldlist ::= field {fieldsep field} fieldsep
field ::= '[' exp ']' '=' exp | Name = 'exp' | exp

fieldsep ::= ',' | ';'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseTableConstructor</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> fields = []
      , key, value;

    <span class="keyword">while</span> (<span class="literal">true</span>) {
      <span class="keyword">if</span> (token.type === Tokens.Punctuator &amp;&amp; consume(<span class="string">'['</span>)) {
        key = parseExpression();
        expect(<span class="string">']'</span>);
        expect(<span class="string">'='</span>);
        value = parseExpression();
        <span class="keyword">if</span> (value == <span class="literal">null</span>)
          raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token);
        fields.push(ast.tableKey(key, value));
      } <span class="keyword">else</span> <span class="keyword">if</span> (token.type === Tokens.Identifier) {
        key = parseExpression();
        <span class="keyword">if</span> (consume(<span class="string">'='</span>)) {
          value = parseExpression();
          fields.push(ast.tableKeyString(key, value));
        } <span class="keyword">else</span> {
          fields.push(ast.tableValue(key));
        }
      } <span class="keyword">else</span> {
        value = parseExpression();
        <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">break</span>;
        fields.push(ast.tableValue(value));
      }
      <span class="keyword">if</span> (~<span class="string">',;'</span>.indexOf(token.value)) {
        next();
        <span class="keyword">continue</span>;
      }
      <span class="keyword">if</span> (token.value === <span class="string">'}'</span>) <span class="keyword">break</span>;
    }
    expect(<span class="string">'}'</span>);
    <span class="keyword">return</span> ast.tableConstructorExpression(fields);
  }

</pre></div>             </td>           </tr>                               <tr id="section-109">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-109">&#182;</a>               </div>               <h2>Expression parser</h2>

<p>Expressions are evaluated and always return a value. Sometimes with side
effects depending on the language.</p>

<pre><code>exp ::= (unop exp | primary | prefixexp ) { binop exp }

primary ::= nil | false | true | Number | String | '...'
     | functiondef | tableconstructor

prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'
     | '.' Name | ':' Name args | args }
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseExpression</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> expression = parseSubExpression(<span class="number">0</span>);
    <span class="keyword">return</span> expression;
  }

</pre></div>             </td>           </tr>                               <tr id="section-110">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-110">&#182;</a>               </div>               <p>Return the precedence priority of the operator.</p>

<p>As unary <code>-</code> can't be distinguished from binary <code>-</code>, unary precedence isn't
described in this table but in <code>parseSubExpression()</code> itself.</p>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">binaryPrecedence</span><span class="params">(operator)</span> {</span>
    <span class="keyword">switch</span> (operator) {
      <span class="keyword">case</span> <span class="string">'^'</span>: <span class="keyword">return</span> <span class="number">10</span>;
      <span class="keyword">case</span> <span class="string">'*'</span>: <span class="keyword">case</span> <span class="string">'/'</span>: <span class="keyword">case</span> <span class="string">'%'</span>: <span class="keyword">return</span> <span class="number">7</span>;
      <span class="keyword">case</span> <span class="string">'+'</span>: <span class="keyword">case</span> <span class="string">'-'</span>: <span class="keyword">return</span> <span class="number">6</span>;
      <span class="keyword">case</span> <span class="string">'..'</span>: <span class="keyword">return</span> <span class="number">5</span>;
      <span class="keyword">case</span> <span class="string">'&lt;'</span>: <span class="keyword">case</span> <span class="string">'&lt;='</span>: <span class="keyword">case</span> <span class="string">'&gt;'</span>: <span class="keyword">case</span> <span class="string">'&gt;='</span>: <span class="keyword">case</span> <span class="string">'=='</span>: <span class="keyword">case</span> <span class="string">'~='</span>: <span class="keyword">return</span> <span class="number">3</span>;
      <span class="keyword">case</span> <span class="string">'and'</span>: <span class="keyword">return</span> <span class="number">2</span>;
      <span class="keyword">case</span> <span class="string">'or'</span>: <span class="keyword">return</span> <span class="number">1</span>;
    }
    <span class="keyword">return</span> <span class="number">0</span>;
  }

</pre></div>             </td>           </tr>                               <tr id="section-111">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-111">&#182;</a>               </div>               <p>Implement an operator-precedence parser to handle binary operator
precedence.</p>

<p>We use this algorithm because it's compact, it's fast and Lua core uses the
same so we can be sure our expressions are parsed in the same manner
without too many tests.</p>

<pre><code>exp ::= (unop exp | primary | prefixexp ) { binop exp }
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseSubExpression</span><span class="params">(minPrecedence)</span> {</span>
    <span class="keyword">var</span> operator = token.value;
</pre></div>             </td>           </tr>                               <tr id="section-112">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-112">&#182;</a>               </div>               <p>The left-hand side in binary operations.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">var</span> expression;

</pre></div>             </td>           </tr>                               <tr id="section-113">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-113">&#182;</a>               </div>               <p>UnaryExpression</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (operator === <span class="string">'#'</span> || operator === <span class="string">'-'</span> || operator === <span class="string">'not'</span>) {
      next();
      <span class="keyword">var</span> argument = parseSubExpression(<span class="number">8</span>);
      <span class="keyword">if</span> (argument == <span class="literal">null</span>) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token);
      expression = ast.unaryExpression(operator, argument);
    } <span class="keyword">else</span> {
</pre></div>             </td>           </tr>                               <tr id="section-114">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-114">&#182;</a>               </div>               <p>PrimaryExpression</p>             </td>             <td class="code">               <div class="highlight"><pre>      expression = parsePrimaryExpression();

</pre></div>             </td>           </tr>                               <tr id="section-115">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-115">&#182;</a>               </div>               <p>PrefixExpression</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (!expression) {
        expression = parsePrefixExpression();
      }
    }
</pre></div>             </td>           </tr>                               <tr id="section-116">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-116">&#182;</a>               </div>               <p>This is not a valid left hand expression.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (!expression) <span class="keyword">return</span> <span class="literal">null</span>;

    <span class="keyword">while</span> (<span class="literal">true</span>) {
      operator = token.value;
      <span class="keyword">var</span> precedence = binaryPrecedence(operator);
      <span class="keyword">if</span> (precedence === <span class="number">0</span> || precedence &lt;= minPrecedence) <span class="keyword">break</span>;
</pre></div>             </td>           </tr>                               <tr id="section-117">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-117">&#182;</a>               </div>               <p>Right-hand precedence operators</p>             </td>             <td class="code">               <div class="highlight"><pre>      <span class="keyword">if</span> (operator === <span class="string">'^'</span> || operator === <span class="string">'..'</span>) precedence--;
      next();
      <span class="keyword">var</span> right = parseSubExpression(precedence);
      <span class="keyword">if</span> (right == <span class="literal">null</span>) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token);
      <span class="keyword">if</span> (expression == <span class="literal">null</span>) raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token);
      expression = ast.binaryExpression(operator, expression, right);
    }
    <span class="keyword">return</span> expression;
  }

</pre></div>             </td>           </tr>                               <tr id="section-118">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-118">&#182;</a>               </div>               <pre><code>prefixexp ::= prefix {suffix}
prefix ::= Name | '(' exp ')'
suffix ::= '[' exp ']' | '.' Name | ':' Name args | args

args ::= '(' [explist] ')' | tableconstructor | String
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parsePrefixExpression</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> base;

</pre></div>             </td>           </tr>                               <tr id="section-119">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-119">&#182;</a>               </div>               <p>The prefix</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (token.type === Tokens.Identifier) {
      base = parseIdentifier();
    } <span class="keyword">else</span> <span class="keyword">if</span> (consume(<span class="string">'('</span>)) {
      base = parseExpression();
      expect(<span class="string">')'</span>);
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> <span class="literal">null</span>;
    }

</pre></div>             </td>           </tr>                               <tr id="section-120">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-120">&#182;</a>               </div>               <p>The suffix</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">var</span> expression, identifier;
    <span class="keyword">while</span> (<span class="literal">true</span>) {
      <span class="keyword">if</span> (base == <span class="literal">null</span>)
        raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token);
      <span class="keyword">if</span> (token.type === Tokens.Punctuator) {
        <span class="keyword">switch</span> (token.value) {
          <span class="keyword">case</span> <span class="string">'['</span>:
            next();
            expression = parseExpression();
            base = ast.indexExpression(base, expression);
            expect(<span class="string">']'</span>);
            <span class="keyword">break</span>;
          <span class="keyword">case</span> <span class="string">'.'</span>:
            next();
            identifier = parseIdentifier();
            base = ast.memberExpression(base, <span class="string">'.'</span>, identifier);
            <span class="keyword">break</span>;
          <span class="keyword">case</span> <span class="string">':'</span>:
            next();
            identifier = parseIdentifier();
            base = ast.memberExpression(base, <span class="string">':'</span>, identifier);
            base = parseCallExpression(base);
            <span class="keyword">break</span>;
          <span class="keyword">case</span> <span class="string">'('</span>: <span class="keyword">case</span> <span class="string">'{'</span>: <span class="comment">// args</span>
            base = parseCallExpression(base);
            <span class="keyword">break</span>;
          <span class="keyword">default</span>:
            <span class="keyword">return</span> base;
        }
      } <span class="keyword">else</span> <span class="keyword">if</span> (token.type === Tokens.StringLiteral) {
        base = parseCallExpression(base);
      } <span class="keyword">else</span> {
        <span class="keyword">break</span>;
      }
    }

    <span class="keyword">return</span> base;
  }

</pre></div>             </td>           </tr>                               <tr id="section-121">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-121">&#182;</a>               </div>               <pre><code>args ::= '(' [explist] ')' | tableconstructor | String
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parseCallExpression</span><span class="params">(base)</span> {</span>
    <span class="keyword">if</span> (token.type === Tokens.Punctuator) {
      <span class="keyword">switch</span> (token.value) {
        <span class="keyword">case</span> <span class="string">'('</span>:
          next();

</pre></div>             </td>           </tr>                               <tr id="section-122">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-122">&#182;</a>               </div>               <p>List of expressions</p>             </td>             <td class="code">               <div class="highlight"><pre>          <span class="keyword">var</span> expressions = [];
          <span class="keyword">var</span> expression = parseExpression();
          <span class="keyword">if</span> (expression) expressions.push(expression);
          <span class="keyword">while</span> (consume(<span class="string">','</span>)) {
            expression = parseExpression();
            <span class="keyword">if</span> (expression == <span class="literal">null</span>)
              raiseUnexpectedToken(<span class="string">'&lt;expression&gt;'</span>, token);
            expressions.push(expression);
          }

          expect(<span class="string">')'</span>);
          <span class="keyword">return</span> ast.callExpression(base, expressions);

        <span class="keyword">case</span> <span class="string">'{'</span>:
          next();
          <span class="keyword">var</span> table = parseTableConstructor();
          <span class="keyword">return</span> ast.tableCallExpression(base, table);
      }

    } <span class="keyword">else</span> <span class="keyword">if</span> (token.type === Tokens.StringLiteral) {
      <span class="keyword">var</span> string = token.value;
      next();
      <span class="keyword">return</span> ast.stringCallExpression(base, string);
    }

    raiseUnexpectedToken(<span class="string">'function arguments'</span>, token);
  }

</pre></div>             </td>           </tr>                               <tr id="section-123">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-123">&#182;</a>               </div>               <pre><code>primary ::= String | Numeric | nil | true | false
     | functiondef | tableconstructor | '...'
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  <span class="function"><span class="keyword">function</span> <span class="title">parsePrimaryExpression</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> node;
    <span class="keyword">switch</span> (token.type) {
      <span class="keyword">case</span> Tokens.StringLiteral:
      <span class="keyword">case</span> Tokens.NumericLiteral:
        node = ast.literal(token.value);
        <span class="keyword">break</span>;
      <span class="keyword">case</span> Tokens.NilLiteral:
        node = ast.literal(<span class="literal">null</span>);
        <span class="keyword">break</span>;
      <span class="keyword">case</span> Tokens.BooleanLiteral:
        node = ast.literal(token.value === <span class="string">'true'</span>);
        <span class="keyword">break</span>;
      <span class="keyword">case</span> Tokens.Keyword:
        <span class="keyword">if</span> (token.value === <span class="string">'function'</span>) {
          next();
          <span class="keyword">return</span> parseFunctionDeclaration(<span class="literal">null</span>); <span class="comment">// @TODO isLocal?</span>
        }
        <span class="keyword">break</span>;
      <span class="keyword">case</span> Tokens.Punctuator:
        <span class="keyword">if</span> (consume(<span class="string">'...'</span>)) <span class="keyword">return</span> ast.varargLiteral(token.value); <span class="comment">// @TODO needs check?</span>
        <span class="keyword">if</span> (consume(<span class="string">'{'</span>)) <span class="keyword">return</span> parseTableConstructor();
        <span class="keyword">break</span>;
    }
    <span class="keyword">if</span> (node) next();
    <span class="keyword">return</span> node;
  }

</pre></div>             </td>           </tr>                               <tr id="section-124">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-124">&#182;</a>               </div>               <h2>Parser</h2>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-125">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-125">&#182;</a>               </div>               <p>Export the main parser.</p>

<ul>
<li><code>wait</code> Hold parsing until end() is called. Defaults to false</li>
</ul>

<p>Example:</p>

<pre><code>var parser = require('luaparser');
parser.parse('i = 0');
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>
  exports.parse = parse;

  <span class="function"><span class="keyword">function</span> <span class="title">parse</span><span class="params">(_input, _options)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> _options === <span class="string">'undefined'</span> &amp;&amp; <span class="keyword">typeof</span> _input === <span class="string">'object'</span>) {
      _options = _input;
      _input = <span class="literal">undefined</span>;
    }
    <span class="keyword">if</span> (!_options) _options = {};

    input = _input || <span class="string">''</span>;
    options = extend(defaultOptions, _options);

    <span class="keyword">if</span> (options.comments) comments = [];

    <span class="keyword">if</span> (!options.wait) <span class="keyword">return</span> end();
    <span class="keyword">return</span> exports;
  }

</pre></div>             </td>           </tr>                               <tr id="section-126">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-126">&#182;</a>               </div>               <p>Write to the source code buffer without beginning the parse.</p>             </td>             <td class="code">               <div class="highlight"><pre>  exports.write = write;

  <span class="function"><span class="keyword">function</span> <span class="title">write</span><span class="params">(_input)</span> {</span>
    input += String(_input);
    <span class="keyword">return</span> exports;
  }

</pre></div>             </td>           </tr>                               <tr id="section-127">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-127">&#182;</a>               </div>               <p>Send an EOF and begin parsing.</p>             </td>             <td class="code">               <div class="highlight"><pre>  exports.end = end;

  <span class="function"><span class="keyword">function</span> <span class="title">end</span><span class="params">(_input)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> _input !== <span class="string">'undefined'</span>) write(_input);

    length = input.length;
    index = <span class="number">0</span>;
    line = <span class="number">1</span>;
    lineStart = <span class="number">0</span>;

    <span class="keyword">var</span> chunk = parseChunk();
    <span class="keyword">if</span> (options.comments) chunk.comments = comments;
    <span class="keyword">return</span> chunk;
  }

}));
<span class="comment">/* vim: set sw=2 ts=2 et tw=80 : */</span>

</pre></div>             </td>           </tr>                </tbody>     </table>   </div> </body> </html> 